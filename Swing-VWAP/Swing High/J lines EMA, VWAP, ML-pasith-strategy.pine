//@version=5
strategy('J lines EMA, VWAP, ML Strategy', overlay=true, precision=4, max_labels_count=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20)


import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels

// Binance Webhook Settings
quantity = input.float(0.20, "Order Quantity (% of equity)", minval=0.01, maxval=1.0, step=0.01, group="Binance Settings")
leverage = input.int(10, "Leverage", minval=1, maxval=125, group="Binance Settings")

// Debug and Alert Settings
show_debug = input.bool(true, "Show Debug Table", group="Debug Settings")

//  additional bar color



len = input.int(14, minval=1, title="Length")  // Input for RSI length
rsi = ta.rsi(close, len)  // Use ta.rsi to calculate RSI

// User-defined bar colors
colorCond1 = input.color(color.new(#056656, 0), title="Overbought BarColor")  // User selects the color for cond1
colorCond2 = input.color(color.new(#801922, 0), title="Oversold BarColor")  // User selects the color for cond2

// Bar color conditions
cond1 = rsi > 60
barcolor(cond1 ? colorCond1 : na)

cond2 = rsi < 40
barcolor(cond2 ? colorCond2 : na)





// Sessions indicator

// User Inputs
show_sesNewyork = input(true, 'Your Session') 
sesNewyork_ses = input.session('1300-2200', 'Session Time')
sesNewyork_color = input.color(#C5ACE8, 'Color')
userOpacity = input.int(95, title="Background Opacity", minval=0, maxval=255)  // User input for opacity
sesNewyork_text = 'Your'

// Timezone input
userTimezone = input.string('UTC+5:30', title='Select Timezone', options=['UTC-12', 'UTC-11', 'UTC-10', 'UTC-9', 'UTC-8', 'UTC-7', 'UTC-6', 'UTC-5', 'UTC-4', 'UTC-3', 'UTC-2', 'UTC-1', 'UTC+0', 'UTC+1', 'UTC+2', 'UTC+3', 'UTC+4', 'UTC+4:30', 'UTC+5', 'UTC+5:30', 'UTC+5:45', 'UTC+6', 'UTC+6:30', 'UTC+7', 'UTC+8', 'UTC+8:45', 'UTC+9', 'UTC+9:30', 'UTC+10', 'UTC+10:30', 'UTC+11', 'UTC+12', 'UTC+12:45', 'UTC+13', 'UTC+14'])


// Session detection based on user timezone
On_sesNewyork = math.sign(nz(time(timeframe.period, sesNewyork_ses, userTimezone)))

LowHighSessionDetector(On_Session, Color_Session, Text_Session) =>
    var float session_high = na
    var float session_low = na
    var label _label = na
    var line _line_high = na
    var line _line_low = na
    var box _fill = na

    // Reset session levels at the start of the new session
    if On_Session and not On_Session[1]
        session_high := high
        session_low := low

    // If the session is on, update highs and lows
    if On_Session
        session_high := math.max(session_high, high)
        session_low := math.min(session_low, low)

        if On_Session and not On_Session[1]
            _label := label.new(bar_index, session_low, Text_Session + ' (' + str.tostring(session_low, '#.#####') + ' - ' + str.tostring(session_high, '#.#####') + ')', color=Color_Session, style=label.style_label_up, textcolor=color.white, size=size.small)
            _line_high := line.new(bar_index, session_high, bar_index, session_high, color=Color_Session, width=2)
            _line_low := line.new(bar_index, session_low, bar_index, session_low, color=Color_Session, width=2)
            _fill := box.new(bar_index, session_high, bar_index, session_low, bgcolor=color.new(Color_Session, userOpacity), border_color=na)

        label.set_xy(_label, bar_index, session_low)
        label.set_text(_label, Text_Session + ' (' + str.tostring(session_low, '#.#####') + ' - ' + str.tostring(session_high, '#.#####') + ')')
        line.set_xy1(_line_high, bar_index, session_high)
        line.set_xy2(_line_high, bar_index, session_high)
        line.set_xy1(_line_low, bar_index, session_low)
        line.set_xy2(_line_low, bar_index, session_low)
        box.set_right(_fill, bar_index)
        box.set_top(_fill, session_high)
        box.set_bottom(_fill, session_low)

// Call the function with user input
if show_sesNewyork
    LowHighSessionDetector(On_sesNewyork, sesNewyork_color, sesNewyork_text)

// Additional LARGE EMA Filter



// User input for moving average type
ma_type = input.string("EMA", title="Select MA Type", options=["SMA", "EMA", "WMA", "SMMA", "HMA", "TMA", "AMA", "LWMA", "EWMA", "VIDYA", "DMA", "EMA Ribbon", "T3"])

// User input for period
period = input.int(200, title="Period", minval=1)

// Function to calculate different moving averages
sma_val = ta.sma(close, period)                       // Simple Moving Average
ema_val = ta.ema(close, period)                       // Exponential Moving Average
wma_val = ta.wma(close, period)                       // Weighted Moving Average
smma_val = ta.sma(close, period)                      // Smoothed Moving Average (same as SMA in Pine Script)
hma_val = ta.hma(close, period)                       // Hull Moving Average
tma_val = ta.sma(ta.sma(close, period), period)       // Triangular Moving Average
ama_val = ta.ema(close, period)                       // Adaptive Moving Average (EMA as placeholder)
lwma_val = ta.wma(close, period)                      // Linear Weighted Moving Average (same as WMA in Pine Script)
ewma_val = ta.ema(close, period)                      // Exponential Weighted Moving Average (EMA as placeholder)
vidya_val = ta.ema(close, period)                     // VIDYA (EMA as placeholder)
dma_val = close[period]                               // Displaced Moving Average (shifted close)
ema_ribbon_val = ta.ema(close, period)                // Exponential Moving Average Ribbon (EMA as placeholder)
t3_val = ta.ema(ta.ema(ta.ema(close, period), period), period) // T3 Moving Average

// Select the moving average based on user input
ma = ma_type == "SMA" ? sma_val :
     ma_type == "EMA" ? ema_val :
     ma_type == "WMA" ? wma_val :
     ma_type == "SMMA" ? smma_val :
     ma_type == "HMA" ? hma_val :
     ma_type == "TMA" ? tma_val :
     ma_type == "AMA" ? ama_val :
     ma_type == "LWMA" ? lwma_val :
     ma_type == "EWMA" ? ewma_val :
     ma_type == "VIDYA" ? vidya_val :
     ma_type == "DMA" ? dma_val :
     ma_type == "EMA Ribbon" ? ema_ribbon_val :
     ma_type == "T3" ? t3_val : na

// Plot the selected moving average
plot(ma, title="Moving Average", color=color.white, linewidth=3)



// MY code



// Initialize variables for cumulative volume and volume-price product
var float sum_volume = 0.0
var float sum_vp = 0.0

// Reset cumulative sums at the start of a new day
if (ta.change(time('D')))
    sum_volume := 0.0
    sum_vp := 0.0

// Accumulate the volume and volume-price product
sum_volume := sum_volume + volume
sum_vp := sum_vp + (close * volume)

// Calculate VWAP
vwap = sum_vp / sum_volume

// Determine if VWAP should be hidden on 3-hour, 4-hour, daily, weekly, or higher timeframes
hide_vwap = timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly or timeframe.multiplier >= 180

// Plot VWAP, setting color to `na` if it should be hidden
plot(vwap, color=hide_vwap ? na : color.rgb(0,0,0, 35), linewidth=2, title="VWAP")

// Set bar color based on price relative to VWAP when VWAP is displayed
barcolor_condition = close > vwap ? color.new(#7cb781, 0) : color.red
barcolor(hide_vwap ? na : barcolor_condition)

// Input for EMA length for smoothed VWAP
ema_length = input.int(10, title="EMA Length for Smoothed VWAP", minval=1)

// Calculate smoothed VWAP using EMA
smoothed_vwap = ta.ema(vwap, ema_length)

// Determine color based on the slope of the smoothed VWAP
vwap_slope_up = ta.change(smoothed_vwap) > 0
smoothed_vwap_color = vwap_slope_up ? color.rgb(32,117,35) : color.rgb(190,10,10)

// Plot smoothed VWAP
plot(smoothed_vwap, color=smoothed_vwap_color, linewidth=2, title="Smoothed VWAP (EMA)")

// Default EMA lengths
length1_default = 72
length2_default = 89
length3_default = 216
length4_default = 267
length5_default = 360
length6_default = 445

// Adjust EMA lengths based on the timeframe
adjust_length(length) =>
    timeframe.multiplier >= 60 ? int(length / 10) : int(length / 5)

length1 = adjust_length(length1_default)
length2 = adjust_length(length2_default)
length3 = adjust_length(length3_default)
length4 = adjust_length(length4_default)
length5 = adjust_length(length5_default)
length6 = adjust_length(length6_default)

// User-defined settings for MA type
ma_type1 = input.string("EMA", title="MA Type 1", options=["SMA", "EMA", "WMA", "HMA", "RMA"])
ma_type2 = input.string("EMA", title="MA Type 2", options=["SMA", "EMA", "WMA", "HMA", "RMA"])
ma_type3 = input.string("EMA", title="MA Type 3", options=["SMA", "EMA", "WMA", "HMA", "RMA"])
ma_type4 = input.string("EMA", title="MA Type 4", options=["SMA", "EMA", "WMA", "HMA", "RMA"])
ma_type5 = input.string("EMA", title="MA Type 5", options=["SMA", "EMA", "WMA", "HMA", "RMA"])
ma_type6 = input.string("EMA", title="MA Type 6", options=["SMA", "EMA", "WMA", "HMA", "RMA"])

// Function to calculate the moving average based on type and length
ma(src, length, type) =>
    if type == "SMA"
        ta.sma(src, length)
    else if type == "EMA"
        ta.ema(src, length)
    else if type == "WMA"
        ta.wma(src, length)
    else if type == "HMA"
        ta.hma(src, length)
    else if type == "RMA"
        ta.rma(src, length)
    else
        na

// Calculate the 6 moving averages
ma1 = ma(close, length1, ma_type1)
ma2 = ma(close, length2, ma_type2)
ma3 = ma(close, length3, ma_type3)
ma4 = ma(close, length4, ma_type4)
ma5 = ma(close, length5, ma_type5)
ma6 = ma(close, length6, ma_type6)

// Plot the 6 moving averages but keep them hidden
plot1 = plot(ma1, color=color.red, linewidth=2, title="MA 1", display=display.none)
plot2 = plot(ma2, color=color.orange, linewidth=2, title="MA 2", display=display.none)
plot3 = plot(ma3, color=color.yellow, linewidth=2, title="MA 3", display=display.none)
plot4 = plot(ma4, color=color.green, linewidth=2, title="MA 4", display=display.none)
plot5 = plot(ma5, color=color.blue, linewidth=2, title="MA 5", display=display.none)
plot6 = plot(ma6, color=color.purple, linewidth=2, title="MA 6", display=display.none)

// Add ribbons between the pairs of EMAs
fill(plot1=plot1, plot2=plot2, color=color.new(color.red, 65), title="Ribbon 1-2")
fill(plot1=plot3, plot2=plot4, color=color.new(color.yellow, 65), title="Ribbon 3-4")
fill(plot1=plot5, plot2=plot6, color=color.new(color.blue, 65), title="Ribbon 5-6")

// ML code now

type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings 
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx 

// ==========================
// ==== Helper Functions ====
// ==========================

series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + 
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + 
             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + 
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

// ================  
// ==== Inputs ==== 
// ================ 

// Settings Object: General User-Defined Inputs
Settings settings = 
 Settings.new(
   close, // source
   8, // neighborsCount
   2000, // maxBarsBack
   5, // featureCount
   10, // colorCompression
   true, // showExits
   false // useDynamicExits
 )
   
// Trade Stats Settings
// Note: The trade stats section is NOT intended to be used as a replacement for proper backtesting. It is intended to be used for calibration purposes only.
showTradeStats = input.bool(true, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration. Useful for optimizing the settings in the Feature Engineering section. This should NOT replace backtesting and should be used for calibration purposes only. Early Signal Flips represent instances where the model changes signals before 4 bars elapses; high values can indicate choppy (ranging) market conditions.', group="General Settings")
useWorstCase = input.bool(false, "Use Worst Case Estimates", tooltip="Whether to use the worst case scenario for backtesting. This option can be useful for creating a conservative estimate that is based on close prices only, thus avoiding the effects of intrabar repainting. This option assumes that the user does not enter when the signal first appears and instead waits for the bar to close as confirmation. On larger timeframes, this can mean entering after a large move has already occurred. Leaving this option disabled is generally better for those that use this indicator as a source of confluence and prefer estimates that demonstrate discretionary mid-bar entries. Leaving this option enabled may be more consistent with traditional backtesting results.", group="General Settings")

// Settings object for user-defined settings
FilterSettings filterSettings =
 FilterSettings.new(
   true, // useVolatilityFilter
   true, // useRegimeFilter 
   true, // useAdxFilter
   -0.1, // regimeThreshold
   20 // adxThreshold
 )

// Filter object for filtering the ML predictions
Filter filter =
 Filter.new(
   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), 
   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),
   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)
 )

// Feature Variables: User-Defined Inputs for calculating Feature Series. 
f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "01", tooltip="The first feature to use for ML predictions.", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 1.", defval=14, inline = "02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=1, inline = "02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline = "03", tooltip="The second feature to use for ML predictions.", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 2.", defval=10, inline = "04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=11, inline = "04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline = "05", tooltip="The third feature to use for ML predictions.", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 3.", defval=20, inline = "06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 3 (if applicable).", defval=1, inline = "06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline = "07", tooltip="The fourth feature to use for ML predictions.", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 4.", defval=20, inline = "08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 4 (if applicable).", defval=2, inline = "08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "09", tooltip="The fifth feature to use for ML predictions.", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 5.", defval=9, inline = "10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 5 (if applicable).", defval=1, inline = "10", group="Feature Engineering")

// FeatureSeries Object: Calculated Feature Series based on Feature Variables
featureSeries = 
 FeatureSeries.new(
   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1
   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2 
   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3
   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4
   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5
 )

// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML
// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization and thus must be set-up in advance.
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object
featureArrays = 
 FeatureArrays.new(
   f1Array, // f1
   f2Array, // f2
   f3Array, // f3
   f4Array, // f4
   f5Array  // f5
 )

// Label Object: Used for classifying historical data as training data for the ML Model
Label direction = 
 Label.new(
   long=1, 
   short=-1, 
   neutral=0
 )

// Derived from General Settings
maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

// EMA Settings 
useEmaFilter = input.bool(title="Use EMA Filter", defval=false, group="Filters", inline="ema")
emaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="ema", tooltip="The period of the EMA used for the EMA Filter.")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = input.bool(title="Use SMA Filter", defval=false, group="Filters", inline="sma")
smaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="sma", tooltip="The period of the SMA used for the SMA Filter.")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

// Nadaraya-Watson Kernel Regression Settings
useKernelFilter = input.bool(true, "Trade with Kernel", group="Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(true, "Show Kernel Estimate", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", tooltip="Uses a crossover based mechanism to smoothen kernel color changes. This often results in less color transitions overall and may result in more ML entry signals being generated.", inline='1', group='Kernel Settings')
h = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50', group="Kernel Settings", inline="kernel")
r = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25', group="Kernel Settings", inline="kernel")
x = input.int(25, "Regression Level", tooltip='Bar index on which to start regression. Controls how tightly fit the kernel estimate is to the data. Smaller values are a tighter fit. Larger values are a looser fit. Recommended range: 2-25', group="Kernel Settings", inline="kernel")
lag = input.int(2, "Lag", tooltip="Lag for crossover detection. Lower values result in earlier crossovers. Recommended range: 1-2", inline='1', group='Kernel Settings')

// Display Settings
showBarColors = input.bool(false, "Show Bar Colors", tooltip="Whether to show the bar colors.", group="Display Settings")
showBarPredictions = input.bool(defval = true, title = "Show Bar Prediction Values", tooltip = "Will show the ML model's evaluation of each bar as an integer.", group="Display Settings")
useAtrOffset = input.bool(defval = false, title = "Use ATR Offset", tooltip = "Will use the ATR offset instead of the bar prediction offset.", group="Display Settings")
barPredictionsOffset = input.float(0, "Bar Prediction Offset", minval=0, tooltip="The offset of the bar predictions as a percentage from the bar high or close.", group="Display Settings")

// =================================
// ==== Next Bar Classification ====
// =================================

// This model specializes specifically in predicting the direction of price action over the course of the next 4 bars. 
// To avoid complications with the ML model, this value is hardcoded to 4 bars but support for other training lengths may be added in the future.
src = settings.source
y_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral
var y_train_array = array.new_int(0)

// Variables used for ML Logic
var predictions = array.new_float(0)
var prediction = 0.
var signal = direction.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)

// =========================
// ====  Core ML Logic  ====
// =========================

// Approximate Nearest Neighbors Search with Lorentzian Distance:
// A novel variation of the Nearest Neighbors (NN) search algorithm that ensures a chronologically uniform distribution of neighbors.

// In a traditional KNN-based approach, we would iterate through the entire dataset and calculate the distance between the current bar 
// and every other bar in the dataset and then sort the distances in ascending order. We would then take the first k bars and use their 
// labels to determine the label of the current bar. 

// There are several problems with this traditional KNN approach in the context of real-time calculations involving time series data:
// - It is computationally expensive to iterate through the entire dataset and calculate the distance between every historical bar and
//   the current bar.
// - Market time series data is often non-stationary, meaning that the statistical properties of the data change slightly over time.
// - It is possible that the nearest neighbors are not the most informative ones, and the KNN algorithm may return poor results if the
//   nearest neighbors are not representative of the majority of the data.

// Previously, the user @capissimo attempted to address some of these issues in several of his PineScript-based KNN implementations by:
// - Using a modified KNN algorithm based on consecutive furthest neighbors to find a set of approximate "nearest" neighbors.
// - Using a sliding window approach to only calculate the distance between the current bar and the most recent n bars in the dataset.

// Of these two approaches, the latter is inherently limited by the fact that it only considers the most recent bars in the overall dataset. 

// The former approach has more potential to leverage historical price action, but is limited by:
// - The possibility of a sudden "max" value throwing off the estimation
// - The possibility of selecting a set of approximate neighbors that are not representative of the majority of the data by oversampling 
//   values that are not chronologically distinct enough from one another
// - The possibility of selecting too many "far" neighbors, which may result in a poor estimation of price action

// To address these issues, a novel Approximate Nearest Neighbors (ANN) algorithm is used in this indicator.

// In the below ANN algorithm:
// 1. The algorithm iterates through the dataset in chronological order, using the modulo operator to only perform calculations every 4 bars.
//    This serves the dual purpose of reducing the computational overhead of the algorithm and ensuring a minimum chronological spacing 
//    between the neighbors of at least 4 bars.
// 2. A list of the k-similar neighbors is simultaneously maintained in both a predictions array and corresponding distances array.
// 3. When the size of the predictions array exceeds the desired number of nearest neighbors specified in settings.neighborsCount, 
//    the algorithm removes the first neighbor from the predictions array and the corresponding distance array.
// 4. The lastDistance variable is overriden to be a distance in the lower 25% of the array. This step helps to boost overall accuracy 
//    by ensuring subsequent newly added distance values increase at a slower rate.
// 5. Lorentzian distance is used as a distance metric in order to minimize the effect of outliers and take into account the warping of 
//    "price-time" due to proximity to significant economic events.

lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex //{
    for i = 0 to sizeLoop //{
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays) 
        if d >= lastDistance and i%4 //{
            lastDistance := d            
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > settings.neighborsCount //{
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
            //}
        //}
    //}
    prediction := array.sum(predictions)
//}

// ============================
// ==== Prediction Filters ====
// ============================

// User Defined Filters: Used for adjusting the frequency of the ML Model's predictions
filter_all = filter.volatility and filter.regime and filter.adx

// Filtered Signal: The model's prediction of future price movement direction with user-defined filters applied
signal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(signal[1])

// Bar-Count Filters: Represents strict filters based on a pre-defined holding period of 4 bars
var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

// Fractal Filters: Derived from relative appearances of signals in a given time series fractal/segment with a default length of 4 bars
isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))
isBuySignal = signal == direction.long and isEmaUptrend and isSmaUptrend
isSellSignal = signal == direction.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

// Kernel Regression Filters: Filters based on Nadaraya-Watson Kernel Regression using the Rational Quadratic Kernel
// For more information on this technique refer to my other open source indicator located here: 
// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting/
c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1
// Kernel Rates of Change
bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate
// Kernel Crossovers
bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) 
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1
// Kernel Colors
color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")
// Alert Variables
bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange
// Bullish and Bearish Filters based on Kernel
isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// ===========================
// ==== Entries and Exits ====
// ===========================

// Entry Conditions: Booleans for ML Model Position Entries
startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend
startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend

// Dynamic Exit Conditions: Booleans for ML Model Position Exits based on Fractal Filters and Kernel Regression Filters
lastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)
lastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)
barsSinceRedEntry = ta.barssince(startShortTrade)
barsSinceRedExit = ta.barssince(alertBullish)
barsSinceGreenEntry = ta.barssince(startLongTrade)
barsSinceGreenExit = ta.barssince(alertBearish)
isValidShortExit = barsSinceRedExit > barsSinceRedEntry
isValidLongExit = barsSinceGreenExit > barsSinceGreenEntry
endLongTradeDynamic = (isBearishChange and isValidLongExit[1])
endShortTradeDynamic = (isBullishChange and isValidShortExit[1])

// Fixed Exit Conditions: Booleans for ML Model Position Exits based on a Bar-Count Filters
endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]
endShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict 
endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict

// =============================
// ==== Strategy Execution =====
// =============================

// Strategy Orders - Buy and Sell Entries (signals are already confirmed)
if startLongTrade and barstate.isconfirmed
    strategy.entry("Long", strategy.long, qty=quantity)

if startShortTrade and barstate.isconfirmed
    strategy.entry("Short", strategy.short, qty=quantity)

// Strategy Exits
if endLongTrade and barstate.isconfirmed
    strategy.close("Long")

if endShortTrade and barstate.isconfirmed
    strategy.close("Short")

// JSON Alert Messages for Smart Webhook with new format
buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "buy", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "sell", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

close_buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "close", "position_side": "long", "entry": ' + str.tostring(close) + '}'

close_sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "close", "position_side": "short", "entry": ' + str.tostring(close) + '}'

// =========================
// ==== Plotting Labels ====
// =========================

// Note: These will not repaint once the most recent bar has fully closed. By default, signals appear over the last closed bar; to override this behavior set offset=0.
plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)
plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)
plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=#3AFF17, size=size.tiny, offset=0)
plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=#FD1707, size=size.tiny, offset=0)

// ================
// ==== Alerts ====
// ================ 

// Custom Alert Messages with JSON format - Only fire when bar is confirmed
if startLongTrade and barstate.isconfirmed
    alert(buy_alert_message, alert.freq_once_per_bar)
    
if startShortTrade and barstate.isconfirmed
    alert(sell_alert_message, alert.freq_once_per_bar)

if endLongTrade and barstate.isconfirmed
    alert(close_buy_alert_message, alert.freq_once_per_bar)

if endShortTrade and barstate.isconfirmed
    alert(close_sell_alert_message, alert.freq_once_per_bar)

// Kernel Estimate Alerts
alertcondition(condition=alertBullish, title='Kernel Bullish Color Change', message='LDC Kernel Bullish ▲ | {{ticker}}@{{close}} | ({{interval}})')
alertcondition(condition=alertBearish, title='Kernel Bearish Color Change', message='LDC Kernel Bearish ▼ | {{ticker}}@{{close}} | ({{interval}})')

// Debug Table to show current status
if show_debug and barstate.islast
    var table debug_table = table.new(position.top_right, 2, 8, bgcolor=color.white, border_width=1)
    
    table.cell(debug_table, 0, 0, "Status", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 1, 0, "Value", text_color=color.black, bgcolor=color.gray)
    
    table.cell(debug_table, 0, 1, "ML Signal", text_color=color.black)
    table.cell(debug_table, 1, 1, signal == direction.long ? "Long" : signal == direction.short ? "Short" : "Neutral", text_color=signal == direction.long ? c_green : signal == direction.short ? c_red : color.gray)
    
    table.cell(debug_table, 0, 2, "Bar Confirmed", text_color=color.black)
    table.cell(debug_table, 1, 2, str.tostring(barstate.isconfirmed), text_color=barstate.isconfirmed ? color.green : color.red)
    
    table.cell(debug_table, 0, 3, "Start Long", text_color=color.black)
    table.cell(debug_table, 1, 3, str.tostring(startLongTrade), text_color=startLongTrade ? c_green : color.gray)
    
    table.cell(debug_table, 0, 4, "Start Short", text_color=color.black)
    table.cell(debug_table, 1, 4, str.tostring(startShortTrade), text_color=startShortTrade ? c_red : color.gray)
    
    table.cell(debug_table, 0, 5, "End Long", text_color=color.black)
    table.cell(debug_table, 1, 5, str.tostring(endLongTrade), text_color=endLongTrade ? c_red : color.gray)
    
    table.cell(debug_table, 0, 6, "End Short", text_color=color.black)
    table.cell(debug_table, 1, 6, str.tostring(endShortTrade), text_color=endShortTrade ? c_green : color.gray)
    
    table.cell(debug_table, 0, 7, "Entry Price", text_color=color.black)
    table.cell(debug_table, 1, 7, str.tostring(math.round(close, 4)), text_color=color.black)

// =========================
// ==== Display Signals ==== 
// =========================

atrSpaced = useAtrOffset ? ta.atr(1) : na
compressionFactor = settings.neighborsCount / settings.colorCompression
c_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : prediction <= 0 ? color.from_gradient(prediction, -compressionFactor, 0, #CC3311, #787b86) : na
c_label = showBarPredictions ? c_pred : na
c_bars = showBarColors ? color.new(c_pred, 50) : na
x_val = bar_index
y_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - hl2*barPredictionsOffset/30
label.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)
barcolor(showBarColors ? color.new(c_pred, 50) : na)

// ===================== 
// ==== Backtesting ====
// =====================

// The following can be used to stream signals to a backtest adapter
backTestStream = switch 
    startLongTrade => 1
    endLongTrade => 2
    startShortTrade => -1
    endShortTrade => -2
plot(backTestStream, "Backtest Stream", display=display.none)

// The following can be used to display real-time trade stats. This can be a useful mechanism for obtaining real-time feedback during Feature Engineering. This does NOT replace the need to properly backtest.
// Note: In this context, a "Stop-Loss" is defined instances where the ML Signal prematurely flips directions before an exit signal can be generated.
[totalWins, totalLosses, totalEarlySignalFlips, totalTrades, tradeStatsHeader, winLossRatio, winRate] = ml.backtest(high, low, open, startLongTrade, endLongTrade, startShortTrade, endShortTrade, isEarlySignalFlip, maxBarsBackIndex, bar_index, settings.source, useWorstCase)

init_table() =>
    c_transparent = color.new(color.black, 100)
    table.new(position.top_right, columns=2, rows=7, frame_color=color.new(color.black, 100), frame_width=1, border_width=1, border_color=c_transparent)

update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, stopLosses) => 
    c_transparent = color.new(color.black, 100)
    table.cell(tbl, 0, 0, tradeStatsHeader, text_halign=text.align_center, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 1, 'Winrate', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 1, str.tostring(totalWins / totalTrades, '#.#%'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 2, 'Trades', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 2, str.tostring(totalTrades, '#') + ' (' + str.tostring(totalWins, '#') + '|' + str.tostring(totalLosses, '#') + ')', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 5, 'WL Ratio', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 5, str.tostring(totalWins / totalLosses, '0.00'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 6, 'Early Signal Flips', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 6, str.tostring(totalEarlySignalFlips, '#'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)

if showTradeStats
    var tbl = ml.init_table()
    if barstate.islast
        update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, totalEarlySignalFlips)
