//@version=5
strategy('Combined Swing-VWAP Strategy', overlay=true, precision=4, max_labels_count=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20)

// ============================================================================================================
// WEBHOOK SETTINGS
// ============================================================================================================
quantity = input.float(0.20, "Order Quantity (% of equity)", minval=0.01, maxval=1.0, step=0.01, group="Webhook Settings", tooltip="Percentage of balance to use (0.20 = 20%)")
leverage = input.int(10, "Leverage", minval=1, maxval=125, group="Webhook Settings", tooltip="Leverage multiplier for futures trading")

// ============================================================================================================
// SECTION 1: MERGED CODE FROM BOTH INDICATORS
// ============================================================================================================

import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels

// ============================================================================================================
// RSI BAR COLOR (From Indicator 1)
// ============================================================================================================

len = input.int(14, minval=1, title="Length", group="RSI Settings")
rsi = ta.rsi(close, len)

colorCond1 = input.color(color.new(#056656, 0), title="Overbought BarColor", group="RSI Settings")
colorCond2 = input.color(color.new(#801922, 0), title="Oversold BarColor", group="RSI Settings")

cond1 = rsi > 60
barcolor(cond1 ? colorCond1 : na)

cond2 = rsi < 40
barcolor(cond2 ? colorCond2 : na)

// ============================================================================================================
// SESSIONS INDICATOR (From Indicator 1)
// ============================================================================================================

show_sesNewyork = input(true, 'Your Session', group="Session Settings") 
sesNewyork_ses = input.session('1300-2200', 'Session Time', group="Session Settings")
sesNewyork_color = input.color(#C5ACE8, 'Color', group="Session Settings")
userOpacity = input.int(95, title="Background Opacity", minval=0, maxval=255, group="Session Settings")
sesNewyork_text = 'Your'

userTimezone = input.string('UTC+5:30', title='Select Timezone', options=['UTC-12', 'UTC-11', 'UTC-10', 'UTC-9', 'UTC-8', 'UTC-7', 'UTC-6', 'UTC-5', 'UTC-4', 'UTC-3', 'UTC-2', 'UTC-1', 'UTC+0', 'UTC+1', 'UTC+2', 'UTC+3', 'UTC+4', 'UTC+4:30', 'UTC+5', 'UTC+5:30', 'UTC+5:45', 'UTC+6', 'UTC+6:30', 'UTC+7', 'UTC+8', 'UTC+8:45', 'UTC+9', 'UTC+9:30', 'UTC+10', 'UTC+10:30', 'UTC+11', 'UTC+12', 'UTC+12:45', 'UTC+13', 'UTC+14'], group="Session Settings")

On_sesNewyork = math.sign(nz(time(timeframe.period, sesNewyork_ses, userTimezone)))

LowHighSessionDetector(On_Session, Color_Session, Text_Session) =>
    var float Hmax = na
    var float Lmin = na
    var int n = 0
    if On_Session == 1 and On_Session[1] != 1
        Hmax := high
        Lmin := low
        n := 0
    if On_Session == 1
        n += 1
        if high > Hmax
            Hmax := high
        if low < Lmin
            Lmin := low
    if On_Session != 1 and On_Session[1] == 1
        box.new(bar_index[n], Hmax, bar_index, Lmin, border_color=Color_Session, bgcolor=color.new(Color_Session, userOpacity), text=Text_Session, text_color=Color_Session, text_halign=text.align_left, text_valign=text.align_top)

if show_sesNewyork
    LowHighSessionDetector(On_sesNewyork, sesNewyork_color, sesNewyork_text)

// ============================================================================================================
// LARGE EMA FILTER (From Indicator 1)
// ============================================================================================================

ma_type = input.string("EMA", title="Select MA Type", options=["SMA", "EMA", "WMA", "SMMA", "HMA", "TMA", "AMA", "LWMA", "EWMA", "VIDYA", "DMA", "EMA Ribbon", "T3"], group="MA Filter Settings")
period = input.int(200, title="Period", minval=1, group="MA Filter Settings")

sma_val = ta.sma(close, period)
ema_val = ta.ema(close, period)
wma_val = ta.wma(close, period)
smma_val = ta.sma(close, period)
hma_val = ta.hma(close, period)
tma_val = ta.sma(ta.sma(close, period), period)
ama_val = ta.ema(close, period)
lwma_val = ta.wma(close, period)
ewma_val = ta.ema(close, period)
vidya_val = ta.ema(close, period)
dma_val = close[period]
ema_ribbon_val = ta.ema(close, period)
t3_val = ta.ema(ta.ema(ta.ema(close, period), period), period)

ma = ma_type == "SMA" ? sma_val :
     ma_type == "EMA" ? ema_val :
     ma_type == "WMA" ? wma_val :
     ma_type == "SMMA" ? smma_val :
     ma_type == "HMA" ? hma_val :
     ma_type == "TMA" ? tma_val :
     ma_type == "AMA" ? ama_val :
     ma_type == "LWMA" ? lwma_val :
     ma_type == "EWMA" ? ewma_val :
     ma_type == "VIDYA" ? vidya_val :
     ma_type == "DMA" ? dma_val :
     ma_type == "EMA Ribbon" ? ema_ribbon_val :
     t3_val

plot(ma, title="Moving Average", color=color.white, linewidth=3)

// ============================================================================================================
// VWAP CALCULATION (From Indicator 1)
// ============================================================================================================

var float sum_volume = 0.0
var float sum_vp = 0.0

if (ta.change(time('D')))
    sum_volume := 0.0
    sum_vp := 0.0

sum_volume := sum_volume + volume
sum_vp := sum_vp + (close * volume)

vwap = sum_vp / sum_volume

hide_vwap = timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly or timeframe.multiplier >= 180

plot(vwap, color=hide_vwap ? na : color.rgb(0,0,0, 35), linewidth=2, title="VWAP")

barcolor_condition = close > vwap ? color.new(#7cb781, 0) : color.red
barcolor(hide_vwap ? na : barcolor_condition)

ema_length = input.int(10, title="EMA Length for Smoothed VWAP", minval=1, group="VWAP Settings")

smoothed_vwap = ta.ema(vwap, ema_length)

vwap_slope_up = ta.change(smoothed_vwap) > 0
smoothed_vwap_color = vwap_slope_up ? color.rgb(32,117,35) : color.rgb(190,10,10)

plot(smoothed_vwap, color=smoothed_vwap_color, linewidth=2, title="Smoothed VWAP (EMA)")

// ============================================================================================================
// EMA RIBBONS (From Indicator 1)
// ============================================================================================================

length1_default = 72
length2_default = 89
length3_default = 216
length4_default = 267
length5_default = 360
length6_default = 445

adjust_length(length) =>
    timeframe.multiplier >= 60 ? length / 2 : length

length1 = adjust_length(length1_default)
length2 = adjust_length(length2_default)
length3 = adjust_length(length3_default)
length4 = adjust_length(length4_default)
length5 = adjust_length(length5_default)
length6 = adjust_length(length6_default)

ma_type1 = input.string("EMA", title="MA Type 1", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type2 = input.string("EMA", title="MA Type 2", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type3 = input.string("EMA", title="MA Type 3", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type4 = input.string("EMA", title="MA Type 4", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type5 = input.string("EMA", title="MA Type 5", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type6 = input.string("EMA", title="MA Type 6", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")

ma(src, length, type) =>
    type == "SMA" ? ta.sma(src, length) :
     type == "EMA" ? ta.ema(src, length) :
     type == "WMA" ? ta.wma(src, length) :
     type == "HMA" ? ta.hma(src, length) :
     ta.rma(src, length)

ma1 = ma(close, length1, ma_type1)
ma2 = ma(close, length2, ma_type2)
ma3 = ma(close, length3, ma_type3)
ma4 = ma(close, length4, ma_type4)
ma5 = ma(close, length5, ma_type5)
ma6 = ma(close, length6, ma_type6)

plot1 = plot(ma1, color=color.red, linewidth=2, title="MA 1", display=display.none)
plot2 = plot(ma2, color=color.orange, linewidth=2, title="MA 2", display=display.none)
plot3 = plot(ma3, color=color.yellow, linewidth=2, title="MA 3", display=display.none)
plot4 = plot(ma4, color=color.green, linewidth=2, title="MA 4", display=display.none)
plot5 = plot(ma5, color=color.blue, linewidth=2, title="MA 5", display=display.none)
plot6 = plot(ma6, color=color.purple, linewidth=2, title="MA 6", display=display.none)

fill(plot1=plot1, plot2=plot2, color=color.new(color.red, 65), title="Ribbon 1-2")
fill(plot1=plot3, plot2=plot4, color=color.new(color.yellow, 65), title="Ribbon 3-4")
fill(plot1=plot5, plot2=plot6, color=color.new(color.blue, 65), title="Ribbon 5-6")

// ============================================================================================================
// ML CODE (From Indicator 1)
// ============================================================================================================

type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings 
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx

series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

Settings settings = 
 Settings.new(close, 8, 2000, 5, 1, false, false)
   
showTradeStats = input.bool(true, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration. Useful for optimizing the settings in the Feature Engineering section. This should NOT replace backtesting and should be used for calibration purposes only. Early Signal Flips represent instances where the model changes signals before 4 bars elapses; high values can indicate choppy (ranging) market conditions.', group="General Settings")
useWorstCase = input.bool(false, "Use Worst Case Estimates", tooltip="Whether to use the worst case scenario for backtesting. This option can be useful for creating a conservative estimate that is based on close prices only, thus avoiding the effects of intrabar repainting. This option assumes that the user does not enter when the signal first appears and instead waits for the bar to close as confirmation. On larger timeframes, this can mean entering after a large move has already occurred. Leaving this option disabled is generally better for those that use this indicator as a source of confluence and prefer estimates that demonstrate discretionary mid-bar entries. Leaving this option enabled may be more consistent with traditional backtesting results.", group="General Settings")

FilterSettings filterSettings =
 FilterSettings.new(true, true, false, -0.1, 20)

Filter filter =
 Filter.new(ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter), ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter))

f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "01", tooltip="The first feature to use for ML predictions.", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 1.", defval=14, inline = "02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=1, inline = "02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline = "03", tooltip="The second feature to use for ML predictions.", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 2.", defval=10, inline = "04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=11, inline = "04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline = "05", tooltip="The third feature to use for ML predictions.", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 3.", defval=20, inline = "06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 3 (if applicable).", defval=1, inline = "06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline = "07", tooltip="The fourth feature to use for ML predictions.", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 4.", defval=20, inline = "08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 4 (if applicable).", defval=2, inline = "08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "09", tooltip="The fifth feature to use for ML predictions.", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 5.", defval=9, inline = "10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 5 (if applicable).", defval=1, inline = "10", group="Feature Engineering")

featureSeries = 
 FeatureSeries.new(
     series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB),
     series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB),
     series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB),
     series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB),
     series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)
 )

var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

featureArrays = 
 FeatureArrays.new(
     f1Array,
     f2Array,
     f3Array,
     f4Array,
     f5Array
 )

Label direction = 
 Label.new(1, -1, 0)

maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

useEmaFilter = input.bool(title="Use EMA Filter", defval=false, group="Filters", inline="ema")
emaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="ema", tooltip="The period of the EMA used for the EMA Filter.")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = input.bool(title="Use SMA Filter", defval=false, group="Filters", inline="sma")
smaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="sma", tooltip="The period of the SMA used for the SMA Filter.")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

useKernelFilter = input.bool(true, "Trade with Kernel", group="Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(true, "Show Kernel Estimate", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", tooltip="Uses a crossover based mechanism to smoothen kernel color changes. This often results in less color transitions overall and may result in more ML entry signals being generated.", inline='1', group='Kernel Settings')
h = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50', group="Kernel Settings", inline="kernel")
r = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25', group="Kernel Settings", inline="kernel")
x = input.int(25, "Regression Level", tooltip='Bar index on which to start regression. Controls how tightly fit the kernel estimate is to the data. Smaller values are a tighter fit. Larger values are a looser fit. Recommended range: 2-25', group="Kernel Settings", inline="kernel")
lag = input.int(2, "Lag", tooltip="Lag for crossover detection. Lower values result in earlier crossovers. Recommended range: 1-2", inline='1', group='Kernel Settings')

showBarColors = input.bool(false, "Show Bar Colors", tooltip="Whether to show the bar colors.", group="Display Settings")
showBarPredictions = input.bool(defval = true, title = "Show Bar Prediction Values", tooltip = "Will show the ML model's evaluation of each bar as an integer.", group="Display Settings")
useAtrOffset = input.bool(defval = false, title = "Use ATR Offset", tooltip = "Will use the ATR offset instead of the bar prediction offset.", group="Display Settings")
barPredictionsOffset = input.float(0, "Bar Prediction Offset", minval=0, tooltip="The offset of the bar predictions as a percentage from the bar high or close.", group="Display Settings")

src = settings.source
y_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral
var y_train_array = array.new_int(0)

var predictions = array.new_float(0)
var prediction = 0.
var signal = direction.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)

lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex
    for i = 0 to sizeLoop by 4
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays)
        if d >= lastDistance and i % 4
            lastDistance := d            
            array.push(distances, d)
            array.push(predictions, array.get(y_train_array, i))
            if array.size(predictions) > settings.neighborsCount
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
    prediction := array.sum(predictions)

filter_all = filter.volatility and filter.regime and filter.adx

signal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(signal[1])

var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))
isBuySignal = signal == direction.long and isEmaUptrend and isSmaUptrend
isSellSignal = signal == direction.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1

bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate

bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) 
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1

color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")

bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange

isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend
startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend

lastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)
lastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)
barsSinceRedEntry = ta.barssince(startShortTrade)
barsSinceRedExit = ta.barssince(alertBullish)
barsSinceGreenEntry = ta.barssince(startLongTrade)
barsSinceGreenExit = ta.barssince(alertBearish)
isValidShortExit = barsSinceRedExit > barsSinceRedEntry
isValidLongExit = barsSinceGreenExit > barsSinceGreenEntry
endLongTradeDynamic = (isBearishChange and isValidLongExit[1])
endShortTradeDynamic = (isBullishChange and isValidShortExit[1])

endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]
endShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict 
endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict

plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)
plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)
plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=#3AFF17, size=size.tiny, offset=0)
plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=#FD1707, size=size.tiny, offset=0)

// ============================================================================================================
// SWING HIGH/LOW (ZIGZAG) CODE (From Indicator 2)
// ============================================================================================================

var line_h = line(na)
var line_h1 = line(na)
var line_l = line(na)
var line_l1 = line(na)
var line_z = line(na)

var index_h = 0
var index_l = 0
var trend = bool(na)

var line_up = line(na)
var line_dn = line(na)
var lbl_h = label(na)
var lbl_l = label(na)

int     swing_len            = input.int(100, "Swing Length", group="Swing Settings")
bool    hide_h_l       = input.bool(true, "Levels", inline = "lvl", group="Swing Settings")
bool    broken_levels  = input.bool(false, "Broken Levels", inline = "lvl", group="Swing Settings")
bool    history_levels = input.bool(false, "History Levels", inline = "lvl", group="Swing Settings")

bool    shadow         = input.bool(true, "Shadow", inline = "s", group="Swing Settings")
int     shadow_width   = input.int(8, "", inline = "s", group="Swing Settings")

color   upper_col      = input.color(#c424e0, "▽", inline = "cc", group="Swing Settings")
color   lower_col      = input.color(#24e075, "△", inline = "cc", group="Swing Settings")

float upper = ta.highest(swing_len)
float lower = ta.lowest(swing_len)

bool upper_trigger = high[1] == upper[1] and high < upper 
bool lower_trigger = low[1] == lower[1] and low > lower

if upper_trigger
    index_h := time[1]

if lower_trigger
    index_l := time[1]

if high == upper 
    trend := true

if low == lower 
    trend := false

// Swing High/Low signals
var bool swing_high_confirmed = false
var bool swing_low_confirmed = false

if not trend and trend[1]
    line_h := line.new(index_h, upper, time, upper, color = hide_h_l ? upper_col : na, width = 2, xloc = xloc.bar_time)
    if shadow
        line_h1 := line.new(index_h, upper, line_h.get_x2(), upper, color = hide_h_l ? color.new(upper_col, 70) : na, width = shadow_width, xloc = xloc.bar_time)
    line_z := line.new(index_l, line_l.get_y1(), line_h.get_x1(), upper, color = lower_col, xloc = xloc.bar_time)
    if not history_levels
        line.delete(line_h[1])
        line.delete(line_h1[1])
    swing_high_confirmed := true
    swing_low_confirmed := false

if trend and not trend[1]
    line_l := line.new(index_l, lower, time, lower, color = hide_h_l ? lower_col : na, width = 2, xloc = xloc.bar_time)
    if shadow
        line_l1 := line.new(index_l, lower, time, lower, color = hide_h_l ? color.new(lower_col,70) : na, width = shadow_width, xloc = xloc.bar_time)
    line_z := line.new(index_h, line_h.get_y1(), line_l.get_x1(), lower, color = upper_col, xloc = xloc.bar_time)
    if not history_levels
        line.delete(line_l[1])
        line.delete(line_l1[1])
    swing_low_confirmed := true
    swing_high_confirmed := false

line_z.set_style(line.style_dashed)
line_l.set_x2(time)
line_l1.set_x2(time)
line_h.set_x2(time)
line_h1.set_x2(time)

bool cross_over  = ta.crossover(low, line_h.get_y1())
bool cross_under = ta.crossunder(high, line_l.get_y1())

if not (trend != trend[1]) and broken_levels
    if cross_over 
        line_h.set_style(line.style_dashed)
        line_h.set_width(1)
    if cross_under and barstate.isconfirmed 
        line_l.set_style(line.style_dashed)
        line_l.set_width(1)

if barstate.islast
    if trend != trend[1]
        line.delete(line_up)
        line.delete(line_dn)
        label.delete(lbl_h)
        label.delete(lbl_l)

    if not trend != trend[1]
        if trend
            line_up := line.new(index_l, line_l.get_y1(), index_h, upper, style = line.style_dashed, color = lower_col, xloc = xloc.bar_time)
        if not trend 
            line_dn := line.new(index_h, line_h.get_y1(), index_l, lower, style = line.style_dashed, color = upper_col, xloc = xloc.bar_time)

    if hide_h_l
        lbl_h := label.new(bar_index, line_h.get_y1(), str.tostring(line_h.get_y1(), "Swing H  (#,###.####)"), style = label.style_label_left, color = color.new(upper_col, 50), textcolor = chart.fg_color)
        lbl_l := label.new(bar_index, line_l.get_y1(), str.tostring(line_l.get_y1(), "Swing L  (#,###.####)"), style = label.style_label_left, color = color.new(lower_col, 50), textcolor = chart.fg_color)

    label.delete(lbl_h[1])
    label.delete(lbl_l[1])
    line.delete(line_dn[1])
    line.delete(line_up[1])

    var tbl = table.new(position.top_right, 10, 10)
    tbl.cell(0,0,"Swing Direction: ", text_color = chart.fg_color)
    tbl.cell(1,0, (trend ? "⬈" : "⬊"), text_color = trend ? lower_col : upper_col, text_size = size.huge)

if not hide_h_l
    label.new(line_h.get_x1(), line_h.get_y2(), "", xloc = xloc.bar_time, color = upper_col)
    label.new(line_l.get_x1(), line_l.get_y2(), "", xloc = xloc.bar_time, style = label.style_label_up, color = lower_col)

plot(na, editable = false)

// ============================================================================================================
// SECTION 2: COMBINED TRADING STRATEGY
// ============================================================================================================

// Strategy Settings
strategy_group = "Strategy Settings"
enable_strategy = input.bool(true, "Enable Strategy", group=strategy_group)

// ============================================================================================================
// ALERT MESSAGES (JSON Format for Advanced Trading Webhook)
// ============================================================================================================

buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "buy", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "sell", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

close_buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "close", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

close_sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "close", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

// ============================================================================================================
// STRATEGY CONDITIONS
// ============================================================================================================

// BUY CONDITIONS:
// 1. Close price above EMA 200 (ma)
// 2. Swing Low confirmed (swing_low_confirmed)
buy_condition = close > ma and swing_low_confirmed

// CLOSE BUY CONDITIONS:
// Close price below Smoothed VWAP (EMA Length = 10)
close_buy_condition = close < smoothed_vwap

// SELL CONDITIONS:
// 1. Close price below EMA 200 (ma)
// 2. Swing High confirmed (swing_high_confirmed)
sell_condition = close < ma and swing_high_confirmed

// CLOSE SELL CONDITIONS:
// Close price above Smoothed VWAP (EMA Length = 10)
close_sell_condition = close > smoothed_vwap

// ============================================================================================================
// STRATEGY EXECUTION WITH ALERTS
// ============================================================================================================

if enable_strategy
    // Long Entry
    if buy_condition and barstate.isconfirmed
        strategy.entry("Long", strategy.long)
        alert(buy_alert_message, alert.freq_once_per_bar)
    
    // Long Exit
    if close_buy_condition and barstate.isconfirmed
        strategy.close("Long")
        alert(close_buy_alert_message, alert.freq_once_per_bar)
    
    // Short Entry
    if sell_condition and barstate.isconfirmed
        strategy.entry("Short", strategy.short)
        alert(sell_alert_message, alert.freq_once_per_bar)
    
    // Short Exit
    if close_sell_condition and barstate.isconfirmed
        strategy.close("Short")
        alert(close_sell_alert_message, alert.freq_once_per_bar)

// Visual Signals
plotshape(buy_condition, title="Buy Signal", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.normal)
plotshape(close_buy_condition, title="Close Buy Signal", location=location.abovebar, color=color.new(color.orange, 0), style=shape.xcross, size=size.small)
plotshape(sell_condition, title="Sell Signal", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.normal)
plotshape(close_sell_condition, title="Close Sell Signal", location=location.belowbar, color=color.new(color.blue, 0), style=shape.xcross, size=size.small)

// ============================================================================================================
// SECTION 3: ALERT CONDITIONS
// ============================================================================================================

// Alert Conditions (for TradingView Alert Creation)
// Note: alertcondition requires constant strings, use {{strategy.order.action}} for webhook compatibility
alertcondition(buy_condition, title="BUY SIGNAL", message='{{strategy.order.action}}')
alertcondition(close_buy_condition, title="CLOSE BUY SIGNAL", message='{{strategy.order.action}}')
alertcondition(sell_condition, title="SELL SIGNAL", message='{{strategy.order.action}}')
alertcondition(close_sell_condition, title="CLOSE SELL SIGNAL", message='{{strategy.order.action}}')

// Combined Alerts
alertcondition(buy_condition or sell_condition, title="ENTRY SIGNAL (BUY/SELL)", message='{{strategy.order.action}}')
alertcondition(close_buy_condition or close_sell_condition, title="EXIT SIGNAL (CLOSE)", message='{{strategy.order.action}}')
