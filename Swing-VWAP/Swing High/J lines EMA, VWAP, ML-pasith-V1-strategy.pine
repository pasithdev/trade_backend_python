//@version=5
strategy('J lines EMA, VWAP, ML-pasith-V1-strategy', overlay=true, precision=4, max_labels_count=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20)

import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels

// ============================================================================
// WEBHOOK SETTINGS
// ============================================================================
quantity = input.float(0.20, "Order Quantity (% of equity)", minval=0.01, maxval=1.0, step=0.01, group="Webhook Settings", tooltip="Percentage of balance to use (0.20 = 20%)")
leverage = input.int(10, "Leverage", minval=1, maxval=125, group="Webhook Settings", tooltip="Leverage multiplier for futures trading")

// Signal Confidence Settings
min_confidence = input.float(0.5, "Minimum Signal Confidence", minval=0.1, maxval=1.0, step=0.1, group="Webhook Settings", tooltip="Minimum confidence score (0.5 = 50%) required to trigger alert")
prevent_duplicates = input.bool(true, "Prevent Duplicate Signals", group="Webhook Settings", tooltip="Only send one alert per direction until position is closed")

// Debug and Alert Settings
show_debug = input.bool(true, "Show Debug Table", group="Debug Settings")

// ============================================================================
// RSI BAR COLOR
// ============================================================================
len = input.int(14, minval=1, title="Length", group="RSI Settings")
rsi = ta.rsi(close, len)

// User-defined bar colors
colorCond1 = input.color(color.new(#056656, 0), title="Overbought BarColor", group="RSI Settings")
colorCond2 = input.color(color.new(#801922, 0), title="Oversold BarColor", group="RSI Settings")

// Bar color conditions
cond1 = rsi > 60
barcolor(cond1 ? colorCond1 : na)

cond2 = rsi < 40
barcolor(cond2 ? colorCond2 : na)

// ============================================================================
// SESSIONS INDICATOR
// ============================================================================
show_sesNewyork = input(true, 'Your Session', group="Session Settings") 
sesNewyork_ses = input.session('1300-2200', 'Session Time', group="Session Settings")
sesNewyork_color = input.color(#C5ACE8, 'Color', group="Session Settings")
userOpacity = input.int(95, title="Background Opacity", minval=0, maxval=255, group="Session Settings")
sesNewyork_text = 'Your'

// Timezone input
userTimezone = input.string('UTC+5:30', title='Select Timezone', options=['UTC-12', 'UTC-11', 'UTC-10', 'UTC-9', 'UTC-8', 'UTC-7', 'UTC-6', 'UTC-5', 'UTC-4', 'UTC-3', 'UTC-2', 'UTC-1', 'UTC+0', 'UTC+1', 'UTC+2', 'UTC+3', 'UTC+4', 'UTC+4:30', 'UTC+5', 'UTC+5:30', 'UTC+5:45', 'UTC+6', 'UTC+6:30', 'UTC+7', 'UTC+8', 'UTC+8:45', 'UTC+9', 'UTC+9:30', 'UTC+10', 'UTC+10:30', 'UTC+11', 'UTC+12', 'UTC+12:45', 'UTC+13', 'UTC+14'], group="Session Settings")

// Session detection based on user timezone
On_sesNewyork = math.sign(nz(time(timeframe.period, sesNewyork_ses, userTimezone)))

LowHighSessionDetector(On_Session, Color_Session, Text_Session) =>
    var int Bar = 0
    var float High = 0.0 
    var float Low = 0.0
    var box BoX = na
    var label LabeL = na 
    if (On_Session[1] == 0 and On_Session == 1)
        Bar := bar_index
        High := high
        Low := low
    else if (On_Session[1] == 1 and On_Session == 1)
        High := math.max(high , High) 
        Low := math.min(low , Low)
    else if On_Session == 0
        High := 0.0 
        Low := 0.0
        Bar := 0

    if On_Session > On_Session[1]
        BoX := box.new(bar_index, High, bar_index, Low, bgcolor = color.new(Color_Session, userOpacity), border_color = color.rgb(34, 101, 155), border_style = line.style_dotted)
        LabeL := label.new(Bar, High , text = Text_Session, xloc = xloc.bar_index, yloc = yloc.price, size = size.small, style = label.style_label_lower_left, textcolor = Color_Session)
    if On_Session and On_Session == On_Session[1]
        box.set_top(BoX, High)
        box.set_bottom(BoX, Low)
        box.set_right(BoX, bar_index)
        label.set_x(LabeL, math.round(math.avg(Bar, bar_index)))
        label.set_y(LabeL, High)

    [High, Low]

// Call the function with user input
if show_sesNewyork
    [HighN, LowN] = LowHighSessionDetector(On_sesNewyork, sesNewyork_color, sesNewyork_text)

// ============================================================================
// LARGE EMA FILTER
// ============================================================================
ma_type = input.string("EMA", title="Select MA Type", options=["SMA", "EMA", "WMA", "SMMA", "HMA", "TMA", "AMA", "LWMA", "EWMA", "VIDYA", "DMA", "EMA Ribbon", "T3"], group="MA Filter")
period = input.int(200, title="Period", minval=1, group="MA Filter")

// Function to calculate different moving averages
sma_val = ta.sma(close, period)
ema_val = ta.ema(close, period)
wma_val = ta.wma(close, period)
smma_val = ta.sma(close, period)
hma_val = ta.hma(close, period)
tma_val = ta.sma(ta.sma(close, period), period)
ama_val = ta.ema(close, period)
lwma_val = ta.wma(close, period)
ewma_val = ta.ema(close, period)
vidya_val = ta.ema(close, period)
dma_val = close[period]
ema_ribbon_val = ta.ema(close, period)
t3_val = ta.ema(ta.ema(ta.ema(close, period), period), period)

// Select the moving average based on user input
ma = ma_type == "SMA" ? sma_val :
     ma_type == "EMA" ? ema_val :
     ma_type == "WMA" ? wma_val :
     ma_type == "SMMA" ? smma_val :
     ma_type == "HMA" ? hma_val :
     ma_type == "TMA" ? tma_val :
     ma_type == "AMA" ? ama_val :
     ma_type == "LWMA" ? lwma_val :
     ma_type == "EWMA" ? ewma_val :
     ma_type == "VIDYA" ? vidya_val :
     ma_type == "DMA" ? dma_val :
     ma_type == "EMA Ribbon" ? ema_ribbon_val :
     ma_type == "T3" ? t3_val : na

plot(ma, title="Moving Average", color=color.white, linewidth=3)

// ============================================================================
// VWAP CALCULATION
// ============================================================================
var float sum_volume = 0.0
var float sum_vp = 0.0

// Reset cumulative sums at the start of a new day
if (ta.change(time('D')))
    sum_volume := 0.0
    sum_vp := 0.0

// Accumulate the volume and volume-price product
sum_volume := sum_volume + volume
sum_vp := sum_vp + (close * volume)

// Calculate VWAP
vwap = sum_vp / sum_volume

// Determine if VWAP should be hidden on higher timeframes
hide_vwap = timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly or timeframe.multiplier >= 180

// Plot VWAP
plot(vwap, color=hide_vwap ? na : color.rgb(0,0,0, 35), linewidth=2, title="VWAP")

// Set bar color based on price relative to VWAP
barcolor_condition = close > vwap ? color.new(#7cb781, 0) : color.red
barcolor(hide_vwap ? na : barcolor_condition)

// Smoothed VWAP
ema_length = input.int(10, title="EMA Length for Smoothed VWAP", minval=1, group="VWAP Settings")
smoothed_vwap = ta.ema(vwap, ema_length)
vwap_slope_up = ta.change(smoothed_vwap) > 0
smoothed_vwap_color = vwap_slope_up ? color.rgb(32,117,35) : color.rgb(190,10,10)
plot(smoothed_vwap, color=smoothed_vwap_color, linewidth=2, title="Smoothed VWAP (EMA)")

// ============================================================================
// EMA RIBBONS
// ============================================================================
length1_default = 72
length2_default = 89
length3_default = 216
length4_default = 267
length5_default = 360
length6_default = 445

adjust_length(length) =>
    timeframe.isminutes and (timeframe.multiplier == 3 or timeframe.multiplier == 5) ? length / timeframe.multiplier : length

length1 = adjust_length(length1_default)
length2 = adjust_length(length2_default)
length3 = adjust_length(length3_default)
length4 = adjust_length(length4_default)
length5 = adjust_length(length5_default)
length6 = adjust_length(length6_default)

ma_type1 = input.string("EMA", title="MA Type 1", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type2 = input.string("EMA", title="MA Type 2", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type3 = input.string("EMA", title="MA Type 3", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type4 = input.string("EMA", title="MA Type 4", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type5 = input.string("EMA", title="MA Type 5", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")
ma_type6 = input.string("EMA", title="MA Type 6", options=["SMA", "EMA", "WMA", "HMA", "RMA"], group="EMA Ribbons")

ma(src, length, type) =>
    if type == "SMA"
        ta.sma(src, length)
    else if type == "EMA"
        ta.ema(src, length)
    else if type == "WMA"
        ta.wma(src, length)
    else if type == "HMA"
        ta.hma(src, length)
    else if type == "RMA"
        ta.rma(src, length)
    else
        na

ma1 = ma(close, length1, ma_type1)
ma2 = ma(close, length2, ma_type2)
ma3 = ma(close, length3, ma_type3)
ma4 = ma(close, length4, ma_type4)
ma5 = ma(close, length5, ma_type5)
ma6 = ma(close, length6, ma_type6)

plot1 = plot(ma1, color=color.red, linewidth=2, title="MA 1", display=display.none)
plot2 = plot(ma2, color=color.orange, linewidth=2, title="MA 2", display=display.none)
plot3 = plot(ma3, color=color.yellow, linewidth=2, title="MA 3", display=display.none)
plot4 = plot(ma4, color=color.green, linewidth=2, title="MA 4", display=display.none)
plot5 = plot(ma5, color=color.blue, linewidth=2, title="MA 5", display=display.none)
plot6 = plot(ma6, color=color.purple, linewidth=2, title="MA 6", display=display.none)

fill(plot1=plot1, plot2=plot2, color=color.new(color.red, 65), title="Ribbon 1-2")
fill(plot1=plot3, plot2=plot4, color=color.new(color.yellow, 65), title="Ribbon 3-4")
fill(plot1=plot5, plot2=plot6, color=color.new(color.blue, 65), title="Ribbon 5-6")

// ============================================================================
// ML CODE - TYPE DEFINITIONS
// ============================================================================
type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings 
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx 

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================
series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + 
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + 
             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

// ============================================================================
// ML INPUTS
// ============================================================================
Settings settings = 
 Settings.new(
   input.source(title='Source', defval=close, group="ML Settings", tooltip="Source of the input data"),
   input.int(title='Neighbors Count', defval=8, group="ML Settings", minval=1, maxval=100, step=1, tooltip="Number of neighbors to consider"),
   input.int(title="Max Bars Back", defval=2000, group="ML Settings"),
   input.int(title="Feature Count", defval=5, group="Feature Engineering", minval=2, maxval=5, tooltip="Number of features to use for ML predictions."),
   input.int(title="Color Compression", defval=1, group="ML Settings", minval=1, maxval=10, tooltip="Compression factor for adjusting the intensity of the color scale."),
   input.bool(title="Show Default Exits", defval=true, group="ML Settings", tooltip="Default exits occur exactly 4 bars after an entry signal.", inline="exits"),
   input.bool(title="Use Dynamic Exits", defval=false, group="ML Settings", tooltip="Dynamic exits attempt to let profits ride by dynamically adjusting the exit threshold.", inline="exits")
 )

FilterSettings filterSettings =
 FilterSettings.new(
   input.bool(title="Use Volatility Filter", defval=true, tooltip="Whether to use the volatility filter.", group="Filters"),
   input.bool(title="Use Regime Filter", defval=true, group="Filters", inline="regime"),
   input.bool(title="Use ADX Filter", defval=false, group="Filters", inline="adx"),
   input.float(title="Threshold", defval=-0.1, minval=-10, maxval=10, step=0.1, tooltip="Threshold for detecting Trending/Ranging markets.", group="Filters", inline="regime"),
   input.int(title="Threshold", defval=20, minval=0, maxval=100, step=1, tooltip="ADX threshold for detecting Trending/Ranging markets.", group="Filters", inline="adx")
 )

Filter filter =
 Filter.new(
   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter),
   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),
   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)
 )

// Feature Variables
f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "01", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", defval=14, inline = "02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", defval=1, inline = "02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline = "03", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", defval=10, inline = "04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", defval=11, inline = "04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline = "05", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", defval=20, inline = "06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", defval=1, inline = "06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline = "07", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", defval=20, inline = "08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", defval=2, inline = "08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "09", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", defval=9, inline = "10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", defval=1, inline = "10", group="Feature Engineering")

featureSeries = 
 FeatureSeries.new(
   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB),
   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), 
   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), 
   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), 
   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)
 )

var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

featureArrays = 
 FeatureArrays.new(
   f1Array,
   f2Array, 
   f3Array, 
   f4Array, 
   f5Array
 )

Label direction = 
 Label.new(
   long=1, 
   short=-1, 
   neutral=0
  )

maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

useEmaFilter = input.bool(title="Use EMA Filter", defval=false, group="Filters", inline="ema")
emaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="ema")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = input.bool(title="Use SMA Filter", defval=false, group="Filters", inline="sma")
smaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="sma")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

// Kernel Settings
useKernelFilter = input.bool(true, "Trade with Kernel", group="Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(true, "Show Kernel Estimate", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", inline='1', group='Kernel Settings')
h = input.int(8, 'Lookback Window', minval=3, group="Kernel Settings", inline="kernel")
r = input.float(8., 'Relative Weighting', step=0.25, group="Kernel Settings", inline="kernel")
x = input.int(25, "Regression Level", group="Kernel Settings", inline="kernel")
lag = input.int(2, "Lag", inline='1', group='Kernel Settings')

// Display Settings
showBarColors = input.bool(false, "Show Bar Colors", group="Display Settings")
showBarPredictions = input.bool(defval = true, title = "Show Bar Prediction Values", group="Display Settings")
useAtrOffset = input.bool(defval = false, title = "Use ATR Offset", group="Display Settings")
barPredictionsOffset = input.float(0, "Bar Prediction Offset", minval=0, group="Display Settings")

// ============================================================================
// ML LOGIC
// ============================================================================
src = settings.source
y_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral
var y_train_array = array.new_int(0)

var predictions = array.new_float(0)
var prediction = 0.
var signal = direction.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)

lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex
    for i = 0 to sizeLoop
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays) 
        if d >= lastDistance and i%4
            lastDistance := d            
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > settings.neighborsCount
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
    prediction := array.sum(predictions)

// ============================================================================
// PREDICTION FILTERS
// ============================================================================
filter_all = filter.volatility and filter.regime and filter.adx
signal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(signal[1])

var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))
isBuySignal = signal == direction.long and isEmaUptrend and isSmaUptrend
isSellSignal = signal == direction.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

// ============================================================================
// KERNEL REGRESSION
// ============================================================================
c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1

bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate

bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) 
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1

color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")

bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange

isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// ============================================================================
// ENTRIES AND EXITS
// ============================================================================
// Confidence Score Calculation (based on multiple factors)
float confidenceScore = math.abs(prediction) / settings.neighborsCount
bool hasHighConfidence = confidenceScore >= min_confidence  // User-defined confidence threshold

// Price momentum confirmation
priceAboveVwap = close > vwap
priceBelowVwap = close < vwap
bool momentumConfirmsLong = priceAboveVwap and vwap_slope_up
bool momentumConfirmsShort = priceBelowVwap and not vwap_slope_up

// Tracking variables for position state (prevent duplicate alerts)
var bool inLongPosition = false
var bool inShortPosition = false
var bool longAlertSent = false
var bool shortAlertSent = false

// Base signal conditions with confidence filter
baseLongSignal = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend and hasHighConfidence and momentumConfirmsLong
baseShortSignal = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend and hasHighConfidence and momentumConfirmsShort

// Prevent duplicate signals - only trigger if NOT already in position and alert not sent
startLongTrade = prevent_duplicates ? (baseLongSignal and not inLongPosition and not longAlertSent) : baseLongSignal
startShortTrade = prevent_duplicates ? (baseShortSignal and not inShortPosition and not shortAlertSent) : baseShortSignal

// Update position tracking
if startLongTrade
    inLongPosition := true
    longAlertSent := true
    inShortPosition := false
    shortAlertSent := false

if startShortTrade
    inShortPosition := true
    shortAlertSent := true
    inLongPosition := false
    longAlertSent := false

lastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)
lastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)
barsSinceRedEntry = ta.barssince(startShortTrade)
barsSinceRedExit = ta.barssince(alertBullish)
barsSinceGreenEntry = ta.barssince(startLongTrade)
barsSinceGreenExit = ta.barssince(alertBearish)
isValidShortExit = barsSinceRedExit > barsSinceRedEntry
isValidLongExit = barsSinceGreenExit > barsSinceGreenEntry
endLongTradeDynamic = (isBearishChange and isValidLongExit[1])
endShortTradeDynamic = (isBullishChange and isValidShortExit[1])

endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]
endShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict 
endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict

// Reset position tracking when trades are closed
if endLongTrade
    inLongPosition := false
    longAlertSent := false

if endShortTrade
    inShortPosition := false
    shortAlertSent := false

// ============================================================================
// PLOTTING SIGNALS
// ============================================================================
plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)
plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)
plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=#3AFF17, size=size.tiny, offset=0)
plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=#FD1707, size=size.tiny, offset=0)

// ============================================================================
// WEBHOOK ALERT MESSAGES
// ============================================================================
buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "buy", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "sell", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

close_buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "close", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

close_sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "close", "balance_percentage": ' + str.tostring(quantity) + ', "leverage": ' + str.tostring(leverage) + ', "entry": ' + str.tostring(close) + '}'

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================
if startLongTrade and barstate.isconfirmed
    strategy.entry("Long", strategy.long)
    alert(buy_alert_message, alert.freq_once_per_bar)

if startShortTrade and barstate.isconfirmed
    strategy.entry("Short", strategy.short)
    alert(sell_alert_message, alert.freq_once_per_bar)

if endLongTrade and barstate.isconfirmed
    strategy.close("Long")
    alert(close_buy_alert_message, alert.freq_once_per_bar)

if endShortTrade and barstate.isconfirmed
    strategy.close("Short")
    alert(close_sell_alert_message, alert.freq_once_per_bar)

// ============================================================================
// ALERT CONDITIONS
// ============================================================================
alertcondition(startLongTrade, title='Buy Signal (Green Arrow)', message='{{strategy.order.action}}')
alertcondition(endLongTrade, title='Close Buy Signal (Green X)', message='{{strategy.order.action}}')
alertcondition(startShortTrade, title='Sell Signal (Red Arrow)', message='{{strategy.order.action}}')
alertcondition(endShortTrade, title='Close Sell Signal (Red X)', message='{{strategy.order.action}}')

// ============================================================================
// DISPLAY PREDICTIONS
// ============================================================================
atrSpaced = useAtrOffset ? ta.atr(1) : na
compressionFactor = settings.neighborsCount / settings.colorCompression
c_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : prediction <= 0 ? color.from_gradient(prediction, -compressionFactor, 0, #CC3311, #787b86) : na
c_label = showBarPredictions ? c_pred : na
c_bars = showBarColors ? color.new(c_pred, 50) : na
x_val = bar_index
y_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - hl2*barPredictionsOffset/30
label.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)
barcolor(showBarColors ? color.new(c_pred, 50) : na)

// ============================================================================
// DEBUG TABLE - Signal Confidence & Position Status
// ============================================================================
if show_debug and barstate.islast
    var table debugTable = table.new(position.top_right, 2, 8, border_width=1)
    
    table.cell(debugTable, 0, 0, "Metric", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 0, "Value", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)
    
    table.cell(debugTable, 0, 1, "Confidence Score", text_color=color.white, text_size=size.small)
    confidencePercent = str.tostring(math.round(confidenceScore * 100, 2)) + "%"
    confidenceColor = hasHighConfidence ? color.green : color.orange
    table.cell(debugTable, 1, 1, confidencePercent, text_color=confidenceColor, text_size=size.small)
    
    table.cell(debugTable, 0, 2, "Min Required", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 2, str.tostring(math.round(min_confidence * 100)) + "%", text_color=color.white, text_size=size.small)
    
    table.cell(debugTable, 0, 3, "Prediction", text_color=color.white, text_size=size.small)
    predColor = prediction > 0 ? color.green : prediction < 0 ? color.red : color.gray
    table.cell(debugTable, 1, 3, str.tostring(prediction), text_color=predColor, text_size=size.small)
    
    table.cell(debugTable, 0, 4, "In Long Position", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 4, inLongPosition ? "YES" : "NO", text_color=inLongPosition ? color.green : color.gray, text_size=size.small)
    
    table.cell(debugTable, 0, 5, "In Short Position", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 5, inShortPosition ? "YES" : "NO", text_color=inShortPosition ? color.red : color.gray, text_size=size.small)
    
    table.cell(debugTable, 0, 6, "Long Alert Sent", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 6, longAlertSent ? "YES" : "NO", text_color=longAlertSent ? color.orange : color.gray, text_size=size.small)
    
    table.cell(debugTable, 0, 7, "Short Alert Sent", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 7, shortAlertSent ? "YES" : "NO", text_color=shortAlertSent ? color.orange : color.gray, text_size=size.small)
