//@version=5
// ============================================================================
// INTELLIGENT CRYPTO SCALPER v1.0
// ============================================================================
//
// DESCRIPTION:
// Professional-grade Pine Script v5 scalping strategy optimized for 
// cryptocurrency markets on the 5-minute timeframe. Implements intelligent 
// market analysis, adaptive risk management, and sophisticated trade execution 
// logic to maximize profitability while minimizing drawdown through smart 
// entry filtering and dynamic profit protection.
//
// KEY FEATURES:
// • Three-tier entry system (High/Medium/Quick confidence levels)
// • Adaptive frequency control with win/loss awareness
// • Dynamic position sizing based on entry tier
// • Multi-level take profit system with trailing stops
// • Immediate breakeven management for profit protection
// • Time-based profit locks (5-bar and 10-bar rules)
// • Volatility-based market regime detection
// • Smart money concepts (liquidity sweeps, breakouts)
// • Comprehensive momentum filtering
// • Recovery mode after consecutive losses
//
// RECOMMENDED SETTINGS:
// • Timeframe: 5-minute
// • Symbols: BTC/USDT, ETH/USDT, major crypto pairs
// • Initial Capital: $10,000
// • Commission: 0.075% per trade
// • Slippage: 2 ticks
//
// PERFORMANCE TARGETS:
// • Win Rate: > 55%
// • Profit Factor: > 2.0
// • Max Drawdown: < 12%
// • Average Trades Per Day: 8-15
//
// AUTHOR: Intelligent Crypto Scalper Team
// VERSION: 1.0
// LAST UPDATED: 2025
//
// ============================================================================

strategy("Intelligent Crypto Scalper v1.0", 
     overlay=true,
     pyramiding=0,
     initial_capital=10000,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100,
     commission_type=strategy.commission.percent,
     commission_value=0.075,
     slippage=2,
     margin_long=100,
     margin_short=100)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================
//
// NAMING CONVENTIONS:
// • Descriptive snake_case for all variables (e.g., atr_period, swing_lookback)
// • Tier suffixes for tier-specific parameters (e.g., _tier1, _tier2, _tier3)
// • Percentage suffix for percentage values (e.g., _pct)
// • Boolean prefixes: enable_, show_, is_
// • Safe value prefix: safe_ (for error-handled values)
// • Threshold suffix: _threshold (for comparison values)
// • Related variables grouped together by functionality
//
// PARAMETER GROUPS:
// 1. Market Analysis: Volatility and structure detection parameters
// 2. Entry Filters (Tier 1/2/3): Tier-specific entry requirements
// 3. Momentum Indicators: Confirmation filter settings
// 4. Risk Management: Position sizing and stop loss parameters
// 5. Take Profit: Multi-level profit target settings
// 6. Frequency Control: Cooldown and rate limiting parameters
// 7. Time-Based Locks: Profit protection time rules
// 8. Visualization: Chart display toggles
// ============================================================================

// ----------------------------------------------------------------------------
// MARKET ANALYSIS PARAMETERS
// ----------------------------------------------------------------------------
atr_period = input.int(14, "ATR Period", minval=5, maxval=30, group="Market Analysis")
swing_lookback = input.int(10, "Swing Lookback Period", minval=5, maxval=20, group="Market Analysis")
volatility_threshold = input.float(1.0, "Volatility Threshold Multiplier", minval=0.5, maxval=2.0, step=0.1, group="Market Analysis")
kaufman_period = input.int(15, "Kaufman Efficiency Period", minval=10, maxval=30, group="Market Analysis")
min_volatility_pct = input.float(0.7, "Minimum Volatility % of Average", minval=0.5, maxval=1.5, step=0.1, group="Market Analysis")

// ----------------------------------------------------------------------------
// ENTRY FILTERS - TIER 1 (HIGH CONFIDENCE)
// ----------------------------------------------------------------------------
enable_tier1 = input.bool(true, "Enable Tier 1 Entries", group="Entry Filters - Tier 1")
volume_spike_tier1 = input.float(2.0, "Volume Spike Multiplier", minval=1.5, maxval=3.0, step=0.1, group="Entry Filters - Tier 1")
min_candle_body_tier1 = input.float(0.4, "Min Candle Body %", minval=0.3, maxval=0.8, step=0.05, group="Entry Filters - Tier 1")
min_confirmations_tier1 = input.int(3, "Min Momentum Confirmations", minval=2, maxval=4, group="Entry Filters - Tier 1")

// ----------------------------------------------------------------------------
// ENTRY FILTERS - TIER 2 (MEDIUM CONFIDENCE)
// ----------------------------------------------------------------------------
enable_tier2 = input.bool(true, "Enable Tier 2 Entries", group="Entry Filters - Tier 2")
volume_spike_tier2 = input.float(1.5, "Volume Spike Multiplier", minval=1.2, maxval=2.0, step=0.1, group="Entry Filters - Tier 2")
min_candle_body_tier2 = input.float(0.25, "Min Candle Body %", minval=0.15, maxval=0.5, step=0.05, group="Entry Filters - Tier 2")
min_confirmations_tier2 = input.int(2, "Min Momentum Confirmations", minval=1, maxval=3, group="Entry Filters - Tier 2")

// ----------------------------------------------------------------------------
// ENTRY FILTERS - TIER 3 (QUICK SCALP)
// ----------------------------------------------------------------------------
enable_tier3 = input.bool(true, "Enable Tier 3 Entries", group="Entry Filters - Tier 3")
volume_spike_tier3 = input.float(2.5, "Volume Spike Multiplier", minval=2.0, maxval=4.0, step=0.1, group="Entry Filters - Tier 3")
min_candle_body_tier3 = input.float(0.5, "Min Candle Body %", minval=0.4, maxval=1.0, step=0.05, group="Entry Filters - Tier 3")
min_confirmations_tier3 = input.int(1, "Min Momentum Confirmations", minval=1, maxval=2, group="Entry Filters - Tier 3")

// ----------------------------------------------------------------------------
// MOMENTUM INDICATORS
// ----------------------------------------------------------------------------
ma_fast_period = input.int(8, "Fast MA Period", minval=5, maxval=15, group="Momentum Indicators")
ma_slope_threshold = input.float(0.002, "MA Slope Threshold", minval=0.001, maxval=0.01, step=0.001, group="Momentum Indicators")
rsi_period = input.int(14, "RSI Period", minval=10, maxval=20, group="Momentum Indicators")
rsi_overbought = input.int(70, "RSI Overbought Level", minval=60, maxval=80, group="Momentum Indicators")
rsi_oversold = input.int(30, "RSI Oversold Level", minval=20, maxval=40, group="Momentum Indicators")
enable_volume_filter = input.bool(true, "Enable Volume Filter", group="Momentum Indicators")
enable_ma_slope_filter = input.bool(true, "Enable MA Slope Filter", group="Momentum Indicators")
enable_candle_body_filter = input.bool(true, "Enable Candle Body Filter", group="Momentum Indicators")
enable_rsi_filter = input.bool(true, "Enable RSI Filter", group="Momentum Indicators")

// ----------------------------------------------------------------------------
// RISK MANAGEMENT
// ----------------------------------------------------------------------------
risk_per_trade_pct = input.float(0.8, "Risk Per Trade %", minval=0.5, maxval=2.0, step=0.1, group="Risk Management")
atr_multiplier_sl = input.float(1.2, "ATR Multiplier for Stop Loss", minval=0.8, maxval=2.0, step=0.1, group="Risk Management")
swing_buffer_pct = input.float(0.1, "Swing Level Buffer %", minval=0.05, maxval=0.3, step=0.05, group="Risk Management")
min_sl_distance_pct = input.float(0.2, "Min Stop Loss Distance %", minval=0.1, maxval=0.5, step=0.05, group="Risk Management")
max_sl_distance_pct = input.float(2.0, "Max Stop Loss Distance %", minval=1.0, maxval=5.0, step=0.5, group="Risk Management")
position_size_tier1_pct = input.float(100, "Tier 1 Position Size %", minval=50, maxval=100, step=10, group="Risk Management")
position_size_tier2_pct = input.float(70, "Tier 2 Position Size %", minval=30, maxval=100, step=10, group="Risk Management")
position_size_tier3_pct = input.float(40, "Tier 3 Position Size %", minval=20, maxval=70, step=10, group="Risk Management")

// ----------------------------------------------------------------------------
// TAKE PROFIT SETTINGS
// ----------------------------------------------------------------------------
tp1_rr_ratio = input.float(0.6, "TP1 Risk:Reward Ratio", minval=0.4, maxval=1.0, step=0.1, group="Take Profit")
tp2_rr_ratio = input.float(1.2, "TP2 Risk:Reward Ratio", minval=0.8, maxval=1.5, step=0.1, group="Take Profit")
partial_close_tp1_pct = input.float(40, "TP1 Partial Close %", minval=30, maxval=50, step=5, group="Take Profit")
partial_close_tp2_pct = input.float(40, "TP2 Partial Close %", minval=30, maxval=50, step=5, group="Take Profit")
trail_atr_multiplier = input.float(0.8, "Trailing Stop ATR Multiplier", minval=0.5, maxval=1.2, step=0.1, group="Take Profit")
breakeven_trigger_rr = input.float(0.6, "Breakeven Trigger R:R", minval=0.4, maxval=1.0, step=0.1, group="Take Profit")
breakeven_offset_pct = input.float(0.1, "Breakeven Offset %", minval=0.05, maxval=0.3, step=0.05, group="Take Profit")

// ----------------------------------------------------------------------------
// FREQUENCY CONTROL
// ----------------------------------------------------------------------------
cooldown_after_win = input.int(0, "Cooldown Bars After Win", minval=0, maxval=5, group="Frequency Control")
cooldown_after_loss = input.int(2, "Cooldown Bars After Loss", minval=1, maxval=5, group="Frequency Control")
cooldown_after_2losses = input.int(5, "Cooldown After 2+ Losses", minval=3, maxval=10, group="Frequency Control")
max_trades_hour_high_vol = input.int(8, "Max Trades/Hour (High Vol)", minval=5, maxval=12, group="Frequency Control")
max_trades_hour_normal = input.int(6, "Max Trades/Hour (Normal)", minval=3, maxval=10, group="Frequency Control")
max_trades_hour_low_vol = input.int(3, "Max Trades/Hour (Low Vol)", minval=1, maxval=5, group="Frequency Control")
enable_win_streak_bonus = input.bool(true, "Enable Win Streak Bonus", group="Frequency Control")
win_streak_threshold = input.int(3, "Win Streak Bonus Threshold", minval=2, maxval=5, group="Frequency Control")
profit_factor_threshold = input.float(1.5, "Min Profit Factor for All Tiers", minval=1.0, maxval=2.0, step=0.1, group="Frequency Control")

// ----------------------------------------------------------------------------
// TIME-BASED PROFIT LOCKS
// ----------------------------------------------------------------------------
enable_time_locks = input.bool(true, "Enable Time-Based Profit Locks", group="Time-Based Locks")
bars_to_breakeven = input.int(5, "Bars to Force Breakeven", minval=3, maxval=10, group="Time-Based Locks")
bars_to_partial_close = input.int(10, "Bars to Force 50% Close", minval=5, maxval=15, group="Time-Based Locks")

// ----------------------------------------------------------------------------
// VISUALIZATION
// ----------------------------------------------------------------------------
show_swing_points = input.bool(true, "Show Swing Points", group="Visualization")
show_sl_tp_lines = input.bool(true, "Show SL/TP Lines", group="Visualization")
show_chop_zones = input.bool(true, "Show Choppy Market Zones", group="Visualization")
show_stats_table = input.bool(true, "Show Performance Statistics", group="Visualization")
show_entry_tier_labels = input.bool(true, "Show Entry Tier Labels", group="Visualization")
show_filtered_signals = input.bool(false, "Show Filtered Signals", group="Visualization")

// ----------------------------------------------------------------------------
// ALERT SETTINGS
// ----------------------------------------------------------------------------
enable_alerts = input.bool(true, "Enable Alerts", group="Alert Settings")
alert_quantity = input.float(0.20, "Order Quantity (% of equity)", minval=0.01, maxval=1.0, step=0.01, group="Alert Settings")
alert_leverage = input.int(10, "Leverage", minval=1, maxval=125, group="Alert Settings")

// ============================================================================
// VOLATILITY ANALYSIS MODULE
// ============================================================================
//
// PURPOSE:
// Determines if market conditions are suitable for scalping by analyzing
// volatility levels and market efficiency. Filters out choppy, sideways
// markets where scalping strategies typically underperform.
//
// COMPONENTS:
// 1. ATR-based volatility measurement
// 2. Kaufman Efficiency Ratio for trend vs noise detection
// 3. Composite volatility filter combining multiple metrics
//
// OUTPUTS:
// • is_tradeable_market: Boolean flag indicating suitable conditions
// • is_high_quality_market: Enhanced flag for optimal conditions
// • market_is_choppy: Warning flag for sideways markets
// ============================================================================

// ----------------------------------------------------------------------------
// 2.1 Calculate ATR and ATR-based volatility metrics
// ----------------------------------------------------------------------------
// ATR (Average True Range) measures market volatility by calculating the
// average range between high and low prices over a specified period.
// We use this to:
// • Determine if market has sufficient movement for scalping
// • Detect volatility expansion (trending conditions)
// • Adapt stop loss and take profit distances

// OPTIMIZATION: Calculate ATR once and store in variable for reuse throughout strategy
// Calculate ATR with configurable period
current_atr = ta.atr(atr_period)

// ERROR HANDLING: Check ATR is not NA before calculations
// Use nz() function for safe defaults (default to 0 if NA)
safe_atr = nz(current_atr, 0.0)

// OPTIMIZATION: Calculate ATR SMA once for relative volatility comparison
atr_sma = ta.sma(safe_atr, atr_period)

// ERROR HANDLING: Ensure atr_sma is not NA
safe_atr_sma = nz(atr_sma, 0.0)

// OPTIMIZATION: Pre-calculate threshold value to avoid repeated multiplication
atr_expansion_threshold = safe_atr_sma * volatility_threshold
atr_minimum_threshold = safe_atr_sma * min_volatility_pct

// OPTIMIZATION: Store validity check result to avoid repeated NA checks
atr_values_valid = not na(safe_atr) and not na(safe_atr_sma) and safe_atr > 0 and safe_atr_sma > 0

// Create volatility expansion detection logic (ATR > SMA(ATR) * threshold)
// Only evaluate if both ATR values are valid (not NA and > 0)
volatility_expanding = atr_values_valid and safe_atr > atr_expansion_threshold

// ----------------------------------------------------------------------------
// 2.2 Implement Kaufman Efficiency Ratio for chop detection
// ----------------------------------------------------------------------------
// Kaufman Efficiency Ratio measures the efficiency of price movement by
// comparing the net price change (signal) to the sum of absolute price
// changes (noise). A low ratio indicates choppy, sideways markets.
//
// Formula: ER = |Price Change| / Sum(|Bar-to-Bar Changes|)
// • ER > 0.3: Trending market (tradeable)
// • ER < 0.3: Choppy market (avoid trading)

// Calculate price change over lookback period (signal)
price_change = math.abs(close - close[kaufman_period])

// Calculate sum of absolute price changes (noise)
noise = math.sum(math.abs(close - close[1]), kaufman_period)

// Compute efficiency ratio (signal / noise)
// Avoid division by zero
efficiency_ratio = noise != 0 ? price_change / noise : 0

// Create choppy market flag when efficiency < 0.3
market_is_choppy = efficiency_ratio < 0.3

// ----------------------------------------------------------------------------
// 2.3 Create composite volatility filter
// ----------------------------------------------------------------------------

// OPTIMIZATION: Reuse pre-calculated threshold and validity check from 2.1
// Check if ATR meets minimum volatility threshold (% of average)
// ERROR HANDLING: Use safe ATR values and validate before comparison
atr_above_minimum = atr_values_valid and safe_atr > atr_minimum_threshold

// Combine ATR and Kaufman metrics for tradeable market conditions
// Market is tradeable when:
// 1. ATR is above minimum threshold
// 2. Market is NOT choppy (efficiency ratio >= 0.3)
// 3. Volatility is expanding (optional boost)
is_tradeable_market = atr_above_minimum and not market_is_choppy

// Enhanced tradeable condition with volatility expansion
is_high_quality_market = is_tradeable_market and volatility_expanding

// ============================================================================
// MARKET STRUCTURE DETECTION MODULE
// ============================================================================
//
// PURPOSE:
// Identifies micro-trends and key price levels through swing point analysis.
// Detects breakouts and liquidity sweeps (false breakouts) which are high-
// probability entry signals in scalping strategies.
//
// SMART MONEY CONCEPTS:
// • Swing Highs/Lows: Key support/resistance levels
// • Breakouts: Price breaking through recent structure
// • Liquidity Sweeps: False breakouts that trap retail traders before reversing
//
// OUTPUTS:
// • bullish_breakout / bearish_breakout: Clean breakout signals
// • liquidity_sweep_long / liquidity_sweep_short: High-probability reversal setups
// ============================================================================

// ----------------------------------------------------------------------------
// 3.1 Create swing high/low detection system
// ----------------------------------------------------------------------------
// Swing points represent recent local highs and lows that act as
// support/resistance levels. We track these to identify breakouts
// and liquidity sweeps.

// Calculate highest high over lookback period
recent_swing_high = ta.highest(high, swing_lookback)

// Calculate lowest low over lookback period
recent_swing_low = ta.lowest(low, swing_lookback)

// ERROR HANDLING: Validate swing levels exist before use
// Use nz() function for safe defaults (use current high/low if NA)
safe_swing_high = nz(recent_swing_high, high)
safe_swing_low = nz(recent_swing_low, low)

// Store previous swing levels for comparison (1 bar ago)
prev_swing_high = safe_swing_high[1]
prev_swing_low = safe_swing_low[1]

// ERROR HANDLING: Ensure previous swing levels are valid
safe_prev_swing_high = nz(prev_swing_high, high)
safe_prev_swing_low = nz(prev_swing_low, low)

// ----------------------------------------------------------------------------
// 3.2 Implement breakout detection logic
// ----------------------------------------------------------------------------

// Calculate tolerance buffer for noise filtering (as percentage of price)
breakout_buffer = swing_buffer_pct / 100

// Detect bullish breakout (close > previous swing high with buffer)
// ERROR HANDLING: Validate swing levels before comparison
bullish_breakout = not na(safe_prev_swing_high) and safe_prev_swing_high > 0 and close > (safe_prev_swing_high * (1 + breakout_buffer))

// Detect bearish breakout (close < previous swing low with buffer)
// ERROR HANDLING: Validate swing levels before comparison
bearish_breakout = not na(safe_prev_swing_low) and safe_prev_swing_low > 0 and close < (safe_prev_swing_low * (1 - breakout_buffer))

// ----------------------------------------------------------------------------
// 3.3 Create liquidity sweep identification
// ----------------------------------------------------------------------------

// Determine if current candle is bullish or bearish
is_bullish_candle = close > open
is_bearish_candle = close < open

// Detect bullish liquidity sweep:
// - Low briefly breaks below swing low (liquidity grab)
// - Close recovers back above swing low (reversal)
// - Candle closes bullish (confirmation)
// ERROR HANDLING: Validate swing levels before comparison
liquidity_sweep_long = not na(safe_prev_swing_low) and safe_prev_swing_low > 0 and low < safe_prev_swing_low and close > safe_prev_swing_low and is_bullish_candle

// Detect bearish liquidity sweep:
// - High briefly breaks above swing high (liquidity grab)
// - Close falls back below swing high (reversal)
// - Candle closes bearish (confirmation)
// ERROR HANDLING: Validate swing levels before comparison
liquidity_sweep_short = not na(safe_prev_swing_high) and safe_prev_swing_high > 0 and high > safe_prev_swing_high and close < safe_prev_swing_high and is_bearish_candle

// ============================================================================
// MOMENTUM FILTER MODULE
// ============================================================================
//
// PURPOSE:
// Confirms directional bias through multiple momentum indicators to filter
// out false signals. Requires multiple confirmations before generating entry
// signals, significantly improving win rate.
//
// INDICATORS:
// 1. Volume Spike Detection: Confirms institutional participation
// 2. Fast MA Slope Analysis: Confirms directional momentum
// 3. Candle Body Size Filter: Confirms strong price movement
// 4. RSI Filter: Avoids extreme overbought/oversold conditions
//
// SCORING SYSTEM:
// Each indicator contributes 1 point to momentum score (0-4)
// Different tiers require different minimum scores:
// • Tier 1: 3+ confirmations (strict)
// • Tier 2: 2+ confirmations (moderate)
// • Tier 3: 1+ confirmations (opportunistic)
// ============================================================================

// ----------------------------------------------------------------------------
// 4.1 Create volume spike detection
// ----------------------------------------------------------------------------
// Volume spikes indicate institutional participation and strong conviction.
// Different tiers use different volume thresholds to balance frequency
// with quality.

// OPTIMIZATION: Calculate volume moving average once and reuse
volume_ma = ta.sma(volume, 20)

// OPTIMIZATION: Pre-calculate volume thresholds to avoid repeated multiplication
volume_threshold_tier1 = volume_ma * volume_spike_tier1
volume_threshold_tier2 = volume_ma * volume_spike_tier2
volume_threshold_tier3 = volume_ma * volume_spike_tier3
volume_threshold_default = volume_ma * 1.5

// Detect volume spikes for each tier (volume > avg * multiplier)
volume_spike_tier1_detected = volume > volume_threshold_tier1
volume_spike_tier2_detected = volume > volume_threshold_tier2
volume_spike_tier3_detected = volume > volume_threshold_tier3

// Output boolean confirmation flag (general volume spike for any tier)
volume_confirms = volume > volume_threshold_default

// ----------------------------------------------------------------------------
// 4.2 Implement fast MA slope analysis
// ----------------------------------------------------------------------------

// Calculate fast moving average (8-period EMA)
ma_fast = ta.ema(close, ma_fast_period)

// Compute MA slope over 3 bars
// Slope = (current MA - MA 3 bars ago) / MA 3 bars ago
ma_slope = ma_fast[3] != 0 ? (ma_fast - ma_fast[3]) / ma_fast[3] : 0

// Determine bullish/bearish slope based on threshold
ma_slope_bullish = ma_slope > ma_slope_threshold
ma_slope_bearish = ma_slope < -ma_slope_threshold

// ----------------------------------------------------------------------------
// 4.3 Create candle body size filter
// ----------------------------------------------------------------------------

// OPTIMIZATION: Calculate candle body percentage once and reuse
candle_body_pct = close != 0 ? math.abs(close - open) / close : 0

// OPTIMIZATION: Calculate recent average candle body once
avg_candle_body = ta.sma(math.abs(close - open) / close, 10)

// OPTIMIZATION: Pre-calculate tier thresholds to avoid repeated division
candle_body_threshold_tier1 = min_candle_body_tier1 / 100
candle_body_threshold_tier2 = min_candle_body_tier2 / 100
candle_body_threshold_tier3 = min_candle_body_tier3 / 100
candle_body_threshold_significant = avg_candle_body * 1.5

// Compare to minimum body percentage threshold for each tier
candle_body_valid_tier1 = candle_body_pct > candle_body_threshold_tier1
candle_body_valid_tier2 = candle_body_pct > candle_body_threshold_tier2
candle_body_valid_tier3 = candle_body_pct > candle_body_threshold_tier3

// Detect significantly larger candles vs recent average (1.5x larger)
candle_significantly_larger = candle_body_pct > candle_body_threshold_significant

// General candle body validation
candle_body_valid = candle_body_pct > 0.003  // 0.3% minimum

// ----------------------------------------------------------------------------
// 4.4 Implement RSI filter for extremes
// ----------------------------------------------------------------------------

// Calculate RSI with configurable period
rsi = ta.rsi(close, rsi_period)

// Create overbought/oversold thresholds
rsi_is_overbought = rsi > rsi_overbought
rsi_is_oversold = rsi < rsi_oversold

// Filter out entries at extreme RSI levels
// RSI is NOT extreme when it's between oversold and overbought levels
rsi_not_extreme = rsi > rsi_oversold and rsi < rsi_overbought

// RSI confirms long when not overbought
rsi_confirms_long = rsi < rsi_overbought

// RSI confirms short when not oversold
rsi_confirms_short = rsi > rsi_oversold

// ----------------------------------------------------------------------------
// 4.5 Create momentum confirmation scoring system
// ----------------------------------------------------------------------------

// OPTIMIZATION: Use ternary operator efficiently for momentum scoring
// Count number of confirmed momentum indicators for LONG entries
momentum_score_long = (enable_volume_filter and volume_confirms ? 1 : 0) + 
                      (enable_ma_slope_filter and ma_slope_bullish ? 1 : 0) + 
                      (enable_candle_body_filter and candle_body_valid ? 1 : 0) + 
                      (enable_rsi_filter and rsi_confirms_long ? 1 : 0)

// Count number of confirmed momentum indicators for SHORT entries
momentum_score_short = (enable_volume_filter and volume_confirms ? 1 : 0) + 
                       (enable_ma_slope_filter and ma_slope_bearish ? 1 : 0) + 
                       (enable_candle_body_filter and candle_body_valid ? 1 : 0) + 
                       (enable_rsi_filter and rsi_confirms_short ? 1 : 0)

// Output momentum score (0-4) - represents total confirmations
// This will be used by entry signal generator to require minimum confirmations

// ============================================================================
// TIERED ENTRY SIGNAL GENERATOR FOR HIGH FREQUENCY TRADING
// ============================================================================
//
// PURPOSE:
// Implements a three-tier entry system to maximize trading frequency while
// maintaining profitability. Each tier has different confidence levels and
// position sizing to balance risk and opportunity.
//
// TIER PHILOSOPHY:
// • Tier 1 (High Confidence): Strictest filters, largest position size (100%)
// • Tier 2 (Medium Confidence): Relaxed filters, medium position size (70%)
// • Tier 3 (Quick Scalp): Opportunistic entries, smallest position size (40%)
//
// BENEFITS:
// • 2-3x more trading opportunities vs single-tier approach
// • Smaller position sizes on lower-confidence setups reduce risk
// • Faster profit-taking on opportunistic trades
// • Maintains overall profitability through tiered risk management
//
// EXPECTED RESULTS:
// • 8-15 trades per day (vs 3-5 with single tier)
// • Win rate: 55-65%
// • Profit factor: 2.0-2.5
// ============================================================================

// ----------------------------------------------------------------------------
// 5.1 Create Tier 1 (High Confidence) long entry logic
// ----------------------------------------------------------------------------
// Tier 1 entries require the strongest confirmation across all filters.
// These trades get the largest position size and standard profit targets.

// Tier 1 Requirements (ALL must be true):
// 1. Market is volatile enough (not choppy)
// 2. Bullish breakout OR liquidity sweep detected
// 3. Momentum score >= 3 confirmations
// 4. Volume spike present
// 5. Enabled via input

tier1_long_entry = enable_tier1 and 
                   is_tradeable_market and 
                   (bullish_breakout or liquidity_sweep_long) and 
                   momentum_score_long >= min_confirmations_tier1 and 
                   volume_spike_tier1_detected

// ----------------------------------------------------------------------------
// 5.2 Create Tier 2 (Medium Confidence) long entry logic
// ----------------------------------------------------------------------------

// Tier 2 Requirements (ALL must be true):
// 1. Market volatility acceptable (ATR > 70% of average)
// 2. Bullish breakout OR strong momentum (score >= 2)
// 3. Momentum score >= 2 confirmations
// 4. Enabled via input
// Note: Previous trade profitability check will be added in frequency control module

tier2_long_entry = enable_tier2 and 
                   atr_above_minimum and 
                   (bullish_breakout or momentum_score_long >= 2) and 
                   momentum_score_long >= min_confirmations_tier2 and 
                   volume_spike_tier2_detected

// ----------------------------------------------------------------------------
// 5.3 Create Tier 3 (Quick Scalp) long entry logic
// ----------------------------------------------------------------------------

// Tier 3 Requirements (ALL must be true):
// 1. Strong volume spike (> 2x average, using tier 3 multiplier)
// 2. Large candle body (> 0.5% move)
// 3. Momentum score >= 1 confirmation
// 4. Enabled via input
// Note: Very tight stop loss and quick profit targets will be set in risk management module

tier3_long_entry = enable_tier3 and 
                   volume_spike_tier3_detected and 
                   candle_body_valid_tier3 and 
                   momentum_score_long >= min_confirmations_tier3

// ----------------------------------------------------------------------------
// 5.4 Create Tier 1, 2, 3 short entry logic (mirror of long logic)
// ----------------------------------------------------------------------------

// Tier 1 Short Entry (High Confidence)
tier1_short_entry = enable_tier1 and is_tradeable_market and (bearish_breakout or liquidity_sweep_short) and momentum_score_short >= min_confirmations_tier1 and volume_spike_tier1_detected

// Tier 2 Short Entry (Medium Confidence)
tier2_short_entry = enable_tier2 and atr_above_minimum and (bearish_breakout or momentum_score_short >= 2) and momentum_score_short >= min_confirmations_tier2 and volume_spike_tier2_detected

// Tier 3 Short Entry (Quick Scalp)
tier3_short_entry = enable_tier3 and volume_spike_tier3_detected and candle_body_valid_tier3 and momentum_score_short >= min_confirmations_tier3

// ----------------------------------------------------------------------------
// 5.5 Implement entry tier selection and position sizing adjustment
// ----------------------------------------------------------------------------

// Determine which tier triggered (priority: Tier 1 > Tier 2 > Tier 3)
// For LONG entries
var int entry_tier_long = 0
var float position_size_multiplier_long = 0.0
var float entry_quality_score_long = 0.0

if tier1_long_entry
    entry_tier_long := 1
    position_size_multiplier_long := position_size_tier1_pct / 100
    // Quality score based on tier (1.0 = highest) and momentum confirmations
    entry_quality_score_long := 1.0 * (momentum_score_long / 4.0)
else if tier2_long_entry
    entry_tier_long := 2
    position_size_multiplier_long := position_size_tier2_pct / 100
    // Quality score: 0.7 base for tier 2, adjusted by momentum
    entry_quality_score_long := 0.7 * (momentum_score_long / 4.0)
else if tier3_long_entry
    entry_tier_long := 3
    position_size_multiplier_long := position_size_tier3_pct / 100
    // Quality score: 0.4 base for tier 3, adjusted by momentum
    entry_quality_score_long := 0.4 * (momentum_score_long / 4.0)
else
    entry_tier_long := 0
    position_size_multiplier_long := 0.0
    entry_quality_score_long := 0.0

// For SHORT entries
var int entry_tier_short = 0
var float position_size_multiplier_short = 0.0
var float entry_quality_score_short = 0.0

if tier1_short_entry
    entry_tier_short := 1
    position_size_multiplier_short := position_size_tier1_pct / 100
    entry_quality_score_short := 1.0 * (momentum_score_short / 4.0)
else if tier2_short_entry
    entry_tier_short := 2
    position_size_multiplier_short := position_size_tier2_pct / 100
    entry_quality_score_short := 0.7 * (momentum_score_short / 4.0)
else if tier3_short_entry
    entry_tier_short := 3
    position_size_multiplier_short := position_size_tier3_pct / 100
    entry_quality_score_short := 0.4 * (momentum_score_short / 4.0)
else
    entry_tier_short := 0
    position_size_multiplier_short := 0.0
    entry_quality_score_short := 0.0

// Combined entry signals (any tier)
enter_long = tier1_long_entry or tier2_long_entry or tier3_long_entry
enter_short = tier1_short_entry or tier2_short_entry or tier3_short_entry

// Selected tier and multiplier (for current bar)
selected_entry_tier = enter_long ? entry_tier_long : (enter_short ? entry_tier_short : 0)
selected_position_size_multiplier = enter_long ? position_size_multiplier_long : (enter_short ? position_size_multiplier_short : 0.0)
selected_entry_quality_score = enter_long ? entry_quality_score_long : (enter_short ? entry_quality_score_short : 0.0)

// ============================================================================
// ADAPTIVE FREQUENCY CONTROL SYSTEM FOR HIGH-FREQUENCY TRADING
// ============================================================================
//
// PURPOSE:
// Prevents overtrading while maximizing opportunities during favorable
// conditions. Implements intelligent cooldown periods that adapt based on
// recent performance and market volatility.
//
// KEY FEATURES:
// 1. Smart Cooldown Manager: Adjusts cooldown based on win/loss history
//    • No cooldown after wins (capitalize on momentum)
//    • 2-3 bar cooldown after losses (avoid revenge trading)
//    • 5 bar cooldown after 2+ consecutive losses (recovery mode)
//
// 2. Win Streak Bonus: Removes cooldown after 3+ consecutive wins
//    • Grants 3 bonus trades with no cooldown
//    • Maximizes profit during hot streaks
//
// 3. Dynamic Hourly Limits: Adjusts based on volatility regime
//    • High volatility: 8 trades/hour
//    • Normal volatility: 6 trades/hour
//    • Low volatility: 3 trades/hour
//
// 4. Profit Factor Monitoring: Switches to Tier 1 only if PF drops below 1.5
//
// 5. Recovery Mode: After 3 consecutive losses, restricts to Tier 1 only
// ============================================================================

// ----------------------------------------------------------------------------
// 6.1 Create smart cooldown manager with win/loss awareness
// ----------------------------------------------------------------------------
// Tracks trade history and implements adaptive cooldown periods based on
// recent performance. This prevents overtrading during unfavorable conditions
// while allowing rapid entries during favorable conditions.

// State variables to track trade history and cooldown
var int last_trade_bar = 0              // Bar index of last trade entry
var int consecutive_wins = 0            // Track consecutive winning trades
var int consecutive_losses = 0          // Track consecutive losing trades
var bool last_trade_was_win = false     // Track if last closed trade was profitable
var int win_streak_bonus_trades = 0     // Remaining bonus trades with no cooldown

// Function to determine cooldown period based on recent performance
get_cooldown_bars() =>
    int cooldown = 0
    
    // Zero cooldown after winning trades
    if last_trade_was_win
        cooldown := cooldown_after_win
    // 2-3 bar cooldown after losing trades (use configured value)
    else if consecutive_losses == 1
        cooldown := cooldown_after_loss
    // 5 bar cooldown after 2+ consecutive losses
    else if consecutive_losses >= 2
        cooldown := cooldown_after_2losses
    else
        // Default cooldown (first trade or neutral state)
        cooldown := cooldown_after_loss
    
    cooldown

// Calculate current cooldown requirement
current_cooldown_bars = get_cooldown_bars()

// Calculate bars since last trade
bars_since_last_trade = bar_index - last_trade_bar

// Calculate bars remaining until next trade allowed
bars_until_next_trade = math.max(0, current_cooldown_bars - bars_since_last_trade)

// Check if cooldown period has elapsed
cooldown_elapsed = bars_since_last_trade >= current_cooldown_bars

// ----------------------------------------------------------------------------
// 6.2 Implement win streak bonus system
// ----------------------------------------------------------------------------

// Check if win streak bonus is active
// After 3+ consecutive wins, provide bonus period of 3 trades with no cooldown
win_streak_bonus_active = enable_win_streak_bonus and 
                          consecutive_wins >= win_streak_threshold and 
                          win_streak_bonus_trades > 0

// Function to update win streak bonus
// This will be called when a trade is entered
update_win_streak_bonus() =>
    int bonus_trades = win_streak_bonus_trades
    
    // If we just hit the win streak threshold, activate bonus
    if enable_win_streak_bonus and consecutive_wins >= win_streak_threshold and bonus_trades == 0
        bonus_trades := 3  // Grant 3 bonus trades
    
    bonus_trades

// Cooldown is waived if:
// 1. Win streak bonus is active, OR
// 2. Last trade was a win (already handled in get_cooldown_bars)
cooldown_waived = win_streak_bonus_active

// Final cooldown check: elapsed OR waived
cooldown_satisfied = cooldown_elapsed or cooldown_waived

// ----------------------------------------------------------------------------
// 6.3 Create dynamic hourly rate limiter based on volatility
// ----------------------------------------------------------------------------

// State variables to track hourly trades
var int current_hour = 0                // Track current hour
var int trades_this_hour = 0            // Count trades within current hour

// Get current hour from timestamp
bar_hour = hour(time)

// Check if hour has changed (reset counter)
hour_changed = bar_hour != current_hour

// Reset trades counter when hour changes
if hour_changed
    trades_this_hour := 0
    current_hour := bar_hour

// Determine volatility regime for dynamic limits
// High volatility: ATR is expanding and above threshold
is_high_volatility = volatility_expanding and is_high_quality_market

// Low volatility: ATR below 70% of average
// ERROR HANDLING: Use safe ATR values
is_low_volatility = not na(safe_atr) and not na(safe_atr_sma) and safe_atr < (safe_atr_sma * 0.7)

// Normal volatility: everything else
is_normal_volatility = not is_high_volatility and not is_low_volatility

// Set dynamic hourly limit based on volatility regime
hourly_trade_limit = is_high_volatility ? max_trades_hour_high_vol : 
                     (is_low_volatility ? max_trades_hour_low_vol : 
                     max_trades_hour_normal)

// Check if hourly limit has been exceeded
hourly_limit_exceeded = trades_this_hour >= hourly_trade_limit

// Hourly limit satisfied (not exceeded)
hourly_limit_satisfied = not hourly_limit_exceeded

// ----------------------------------------------------------------------------
// 6.4 Implement profit factor monitoring and adaptive throttling
// ----------------------------------------------------------------------------

// State variables for profit factor tracking
var float total_gross_profit = 0.0      // Sum of all winning trades
var float total_gross_loss = 0.0        // Sum of all losing trades (absolute value)
var bool recovery_mode = false          // Flag for recovery mode (Tier 1 only)

// Calculate real-time profit factor for current session
// Profit Factor = Gross Profit / Gross Loss
// Avoid division by zero
current_profit_factor = total_gross_loss > 0 ? total_gross_profit / total_gross_loss : (total_gross_profit > 0 ? 999.0 : 1.0)

// Check if profit factor is below threshold
profit_factor_low = current_profit_factor < profit_factor_threshold

// Enter recovery mode after 3 consecutive losses
// Recovery mode restricts trading to Tier 1 only
if consecutive_losses >= 3
    recovery_mode := true

// Exit recovery mode after 2 consecutive wins
if consecutive_wins >= 2 and recovery_mode
    recovery_mode := false

// Determine if recovery mode restricts current entry
// In recovery mode, only Tier 1 entries are allowed
recovery_mode_restricts_tier2 = recovery_mode and (tier2_long_entry or tier2_short_entry)
recovery_mode_restricts_tier3 = recovery_mode and (tier3_long_entry or tier3_short_entry)

// If profit factor is low, also restrict to Tier 1 only
profit_factor_restricts_tier2 = profit_factor_low and (tier2_long_entry or tier2_short_entry)
profit_factor_restricts_tier3 = profit_factor_low and (tier3_long_entry or tier3_short_entry)

// Combined restriction check
tier_restricted = recovery_mode_restricts_tier2 or recovery_mode_restricts_tier3 or 
                  profit_factor_restricts_tier2 or profit_factor_restricts_tier3

// Adaptive throttling satisfied (not restricted)
adaptive_throttling_satisfied = not tier_restricted

// ----------------------------------------------------------------------------
// 6.5 Combine all frequency controls into can_trade flag
// ----------------------------------------------------------------------------

// Master can_trade flag combines all frequency control checks:
// 1. Cooldown period has elapsed (or waived due to win streak bonus)
// 2. Hourly limit not exceeded for current volatility regime
// 3. Adaptive throttling allows the current tier (not in recovery mode restriction)

can_trade = cooldown_satisfied and hourly_limit_satisfied and adaptive_throttling_satisfied

// Determine allowed tiers based on recovery mode and profit factor
// Returns which tiers are currently allowed to trade
tier1_allowed = true  // Tier 1 is always allowed
tier2_allowed = not recovery_mode and not profit_factor_low
tier3_allowed = not recovery_mode and not profit_factor_low

// Apply tier restrictions to entry signals
// Only allow entries for tiers that are currently permitted
tier1_long_allowed = tier1_long_entry and tier1_allowed and can_trade
tier2_long_allowed = tier2_long_entry and tier2_allowed and can_trade
tier3_long_allowed = tier3_long_entry and tier3_allowed and can_trade

tier1_short_allowed = tier1_short_entry and tier1_allowed and can_trade
tier2_short_allowed = tier2_short_entry and tier2_allowed and can_trade
tier3_short_allowed = tier3_short_entry and tier3_allowed and can_trade

// Final entry signals with frequency control applied
enter_long_controlled = tier1_long_allowed or tier2_long_allowed or tier3_long_allowed
enter_short_controlled = tier1_short_allowed or tier2_short_allowed or tier3_short_allowed

// Update selected tier based on allowed entries
final_entry_tier = 0
final_position_size_multiplier = 0.0
final_entry_quality_score = 0.0

if tier1_long_allowed or tier1_short_allowed
    final_entry_tier := 1
    final_position_size_multiplier := position_size_tier1_pct / 100
    final_entry_quality_score := tier1_long_allowed ? entry_quality_score_long : entry_quality_score_short
else if tier2_long_allowed or tier2_short_allowed
    final_entry_tier := 2
    final_position_size_multiplier := position_size_tier2_pct / 100
    final_entry_quality_score := tier2_long_allowed ? entry_quality_score_long : entry_quality_score_short
else if tier3_long_allowed or tier3_short_allowed
    final_entry_tier := 3
    final_position_size_multiplier := position_size_tier3_pct / 100
    final_entry_quality_score := tier3_long_allowed ? entry_quality_score_long : entry_quality_score_short

// ============================================================================
// TIERED RISK MANAGEMENT MODULE WITH PROFIT GUARANTEES
// ============================================================================
//
// PURPOSE:
// Implements sophisticated risk management with multiple layers of profit
// protection to ensure frequent trading remains profitable. Uses tiered
// position sizing and adaptive stop loss/take profit calculations.
//
// PROFIT GUARANTEE MECHANISMS:
// 1. Immediate Breakeven Management
//    • Moves stop to entry + 0.1% as soon as TP1 hits
//    • Ensures every trade reaching first target becomes profitable
//
// 2. Tiered Position Sizing
//    • Tier 1: 100% of calculated size (high confidence)
//    • Tier 2: 70% of calculated size (medium confidence)
//    • Tier 3: 40% of calculated size (opportunistic)
//
// 3. Three-Level Take Profit System
//    • TP1 (40%): 0.6:1 R:R - Ultra-quick profit
//    • TP2 (40%): 1.2:1 R:R - Standard profit
//    • TP3 (20%): Trailing stop with 0.8x ATR
//
// 4. Time-Based Profit Locks
//    • 5-bar rule: Move to breakeven if no TP1 after 5 bars
//    • 10-bar rule: Close 50% at market if no TP1 after 10 bars
//
// 5. Adaptive Stop Loss
//    • Tier 1/2: ATR-based or swing-based (whichever is closer)
//    • Tier 3: Very tight stops (< 0.3%) for quick scalps
//
// EXPECTED OUTCOME:
// • Win rate: 55-65% (higher due to quick profit-taking)
// • Profit factor: 2.0-2.5 (protected by breakeven management)
// • Max drawdown: 8-12% (controlled by tiered sizing)
// ============================================================================

// ----------------------------------------------------------------------------
// 7.1 Create tiered position sizing calculator
// ----------------------------------------------------------------------------
// Calculates position size based on account equity, risk percentage, and
// entry tier. Smaller positions for lower-confidence setups reduce overall
// risk while maintaining trading frequency.

// Calculate current equity (initial capital + net profit)
current_equity = strategy.initial_capital + strategy.netprofit

// Compute base risk amount (equity * risk percentage)
// Using 0.8% as configured in inputs (risk_per_trade_pct)
base_risk_amount = current_equity * (risk_per_trade_pct / 100)

// Function to calculate position size based on tier and stop distance
// Parameters:
// - stop_distance_pct: Stop loss distance as percentage of entry price
// - tier: Entry tier (1, 2, or 3)
// Returns: Position size in base currency
calculate_position_size(float stop_distance_pct, int tier) =>
    // ERROR HANDLING: Validate inputs before calculation
    // Ensure stop distance is positive and non-zero
    if stop_distance_pct <= 0 or na(stop_distance_pct)
        0.0
    else if current_equity <= 0 or na(current_equity)
        0.0
    else
        // Apply tier multiplier to base risk
        // Tier 1 = 100%, Tier 2 = 70%, Tier 3 = 40%
        float tier_multiplier = tier == 1 ? 1.0 : (tier == 2 ? 0.7 : 0.4)
        
        // Calculate adjusted risk amount for this tier
        float adjusted_risk = base_risk_amount * tier_multiplier
        
        // Calculate position size based on stop distance
        // Position Size = Risk Amount / (Entry Price * Stop Distance %)
        // Simplified: Risk Amount / Stop Distance % gives us the position value
        float position_size = adjusted_risk / stop_distance_pct
        
        // Return position size as percentage of equity
        // Convert to percentage: (position_size / current_equity) * 100
        float position_size_pct = (position_size / current_equity) * 100
        
        // ERROR HANDLING: Ensure position size is positive and non-zero
        math.max(0.0, position_size_pct)

// Function to apply min/max position size limits
// Parameters:
// - calculated_size: The calculated position size percentage
// Returns: Position size clamped to min/max limits
apply_position_limits(float calculated_size) =>
    // ERROR HANDLING: Validate calculated size is not NA
    float safe_size = nz(calculated_size, 0.0)
    
    // ERROR HANDLING: Ensure position size is positive and non-zero
    if safe_size <= 0
        0.0  // Skip trade if position size invalid
    else
        // Define minimum and maximum position size limits (as % of equity)
        float min_position_size = 5.0   // Minimum 5% of equity
        float max_position_size = 100.0 // Maximum 100% of equity (full account)
        
        // ERROR HANDLING: Cap position size at maximum allowed
        // Clamp position size to limits
        float limited_size = math.max(min_position_size, math.min(safe_size, max_position_size))
        
        limited_size

// ----------------------------------------------------------------------------
// 7.2 Implement adaptive stop loss calculation with tighter scalping stops
// ----------------------------------------------------------------------------

// Function to calculate ATR-based stop loss distance
// For scalping, we use 1.2x ATR (tighter than traditional strategies)
// Parameters:
// - entry_price: The entry price for the trade
// - is_long: True for long positions, false for short positions
// Returns: Stop loss price
calculate_atr_stop_loss(float entry_price, bool is_long) =>
    // Calculate stop distance using ATR multiplier (1.2x for scalping)
    // ERROR HANDLING: Use safe ATR value
    float stop_distance = safe_atr * atr_multiplier_sl
    
    // Calculate stop loss price
    float stop_price = is_long ? entry_price - stop_distance : entry_price + stop_distance
    
    stop_price

// Function to calculate swing-based stop loss
// Uses recent swing highs/lows with a buffer
// Parameters:
// - entry_price: The entry price for the trade
// - is_long: True for long positions, false for short positions
// Returns: Stop loss price
calculate_swing_stop_loss(float entry_price, bool is_long) =>
    // Calculate buffer as percentage of swing level
    float buffer_multiplier = 1.0 - (swing_buffer_pct / 100)
    
    // For long positions, use swing low with buffer below it
    // For short positions, use swing high with buffer above it
    float stop_price = is_long ? 
                       recent_swing_low * buffer_multiplier : 
                       recent_swing_high * (2.0 - buffer_multiplier)
    
    stop_price

// Function to calculate tier-specific stop loss
// Tier 3 uses very tight stops (< 0.3%)
// Parameters:
// - entry_price: The entry price for the trade
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: Stop loss price
calculate_tier_stop_loss(float entry_price, int tier, bool is_long) =>
    float stop_price = 0.0
    
    // For Tier 3, use very tight stops (0.3% max)
    if tier == 3
        float tight_stop_distance = entry_price * 0.003  // 0.3%
        stop_price := is_long ? entry_price - tight_stop_distance : entry_price + tight_stop_distance
    else
        // For Tier 1 and 2, calculate both ATR and swing-based stops
        float atr_stop = calculate_atr_stop_loss(entry_price, is_long)
        float swing_stop = calculate_swing_stop_loss(entry_price, is_long)
        
        // Choose optimal stop (closer to entry but not too tight)
        // For long: use the higher of the two (closer to entry)
        // For short: use the lower of the two (closer to entry)
        stop_price := is_long ? math.max(atr_stop, swing_stop) : math.min(atr_stop, swing_stop)
    
    stop_price

// Function to enforce minimum and maximum stop distance per tier
// Parameters:
// - entry_price: The entry price for the trade
// - stop_price: The calculated stop loss price
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: Validated stop loss price
validate_stop_distance(float entry_price, float stop_price, int tier, bool is_long) =>
    // ERROR HANDLING: Validate inputs before calculation
    if na(entry_price) or entry_price <= 0 or na(stop_price) or stop_price <= 0
        // Return invalid stop if inputs are bad
        0.0
    else
        // Calculate stop distance as percentage
        float stop_distance_pct = math.abs(entry_price - stop_price) / entry_price
        
        // Define tier-specific min/max stop distances
        float min_stop_pct = tier == 3 ? 0.002 : (tier == 2 ? 0.003 : min_sl_distance_pct / 100)  // Tier 3: 0.2%, Tier 2: 0.3%, Tier 1: configured
        float max_stop_pct = tier == 3 ? 0.003 : (tier == 2 ? 0.015 : max_sl_distance_pct / 100)  // Tier 3: 0.3%, Tier 2: 1.5%, Tier 1: configured
        
        // ERROR HANDLING: Verify stop loss is not too close to entry
        // ERROR HANDLING: Ensure stop loss is not too far from entry
        // Clamp stop distance to tier-specific limits
        float clamped_distance_pct = math.max(min_stop_pct, math.min(stop_distance_pct, max_stop_pct))
        
        // Recalculate stop price with clamped distance
        float validated_stop = is_long ? 
                               entry_price * (1.0 - clamped_distance_pct) : 
                               entry_price * (1.0 + clamped_distance_pct)
        
        validated_stop

// Master function to calculate adaptive stop loss
// Combines all stop loss logic with tier-specific adjustments
// Parameters:
// - entry_price: The entry price for the trade
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: Final stop loss price and distance percentage
calculate_adaptive_stop_loss(float entry_price, int tier, bool is_long) =>
    // ERROR HANDLING: Validate entry price before calculation
    if na(entry_price) or entry_price <= 0
        // Return invalid values if entry price is bad
        [0.0, 0.0]
    else
        // Calculate tier-specific stop loss
        float stop_price = calculate_tier_stop_loss(entry_price, tier, is_long)
        
        // Validate and enforce min/max distances
        float validated_stop = validate_stop_distance(entry_price, stop_price, tier, is_long)
        
        // ERROR HANDLING: Skip trade if stop distance invalid
        if validated_stop <= 0 or na(validated_stop)
            [0.0, 0.0]
        else
            // Calculate final stop distance as percentage
            float stop_distance_pct = math.abs(entry_price - validated_stop) / entry_price
            
            [validated_stop, stop_distance_pct]

// ----------------------------------------------------------------------------
// 7.3 Create three-tier dynamic take profit system
// ----------------------------------------------------------------------------

// Function to calculate TP1 (40% position): Ultra-quick profit
// Uses 0.6:1 R:R for fast profit-taking
// Parameters:
// - entry_price: The entry price for the trade
// - stop_distance: Stop loss distance in price units
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: TP1 price
calculate_tp1(float entry_price, float stop_distance, int tier, bool is_long) =>
    // Base R:R ratio from inputs (default 0.6:1)
    float base_rr = tp1_rr_ratio
    
    // Adjust R:R for different tiers (tighter for Tier 2/3)
    float adjusted_rr = tier == 1 ? base_rr : (tier == 2 ? base_rr * 0.85 : base_rr * 0.7)
    
    // Calculate TP1 distance
    float tp1_distance = stop_distance * adjusted_rr
    
    // Calculate TP1 price
    float tp1_price = is_long ? entry_price + tp1_distance : entry_price - tp1_distance
    
    tp1_price

// Function to calculate TP2 (40% position): Standard profit
// Uses 1.2:1 R:R for standard profit-taking
// Parameters:
// - entry_price: The entry price for the trade
// - stop_distance: Stop loss distance in price units
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: TP2 price
calculate_tp2(float entry_price, float stop_distance, int tier, bool is_long) =>
    // Base R:R ratio from inputs (default 1.2:1)
    float base_rr = tp2_rr_ratio
    
    // Adjust R:R for different tiers (tighter for Tier 2/3)
    float adjusted_rr = tier == 1 ? base_rr : (tier == 2 ? base_rr * 0.85 : base_rr * 0.7)
    
    // Calculate TP2 distance
    float tp2_distance = stop_distance * adjusted_rr
    
    // Calculate TP2 price
    float tp2_price = is_long ? entry_price + tp2_distance : entry_price - tp2_distance
    
    tp2_price

// Function to calculate TP3 trailing stop distance (20% position)
// Uses 0.8x ATR for tight trailing
// Parameters:
// - current_atr_value: Current ATR value
// Returns: Trailing stop distance
calculate_tp3_trail_distance(float current_atr_value) =>
    // Use ATR multiplier from inputs (default 0.8x)
    float trail_distance = current_atr_value * trail_atr_multiplier
    
    trail_distance

// Function to initialize trailing stop for TP3
// Activated after TP2 is hit
// Parameters:
// - entry_price: The entry price for the trade
// - current_price: Current market price
// - trail_distance: Trailing stop distance
// - is_long: True for long positions, false for short positions
// Returns: Initial trailing stop price
initialize_trailing_stop(float entry_price, float current_price, float trail_distance, bool is_long) =>
    // For long positions: trail_stop = current_price - trail_distance
    // For short positions: trail_stop = current_price + trail_distance
    float trail_stop = is_long ? current_price - trail_distance : current_price + trail_distance
    
    // Ensure trailing stop is not worse than entry (for safety)
    float safe_trail_stop = is_long ? math.max(trail_stop, entry_price) : math.min(trail_stop, entry_price)
    
    safe_trail_stop

// Function to update trailing stop as price moves favorably
// Parameters:
// - current_trail_stop: Current trailing stop price
// - current_price: Current market price
// - trail_distance: Trailing stop distance
// - is_long: True for long positions, false for short positions
// Returns: Updated trailing stop price
update_trailing_stop(float current_trail_stop, float current_price, float trail_distance, bool is_long) =>
    // Calculate new potential trailing stop
    float new_trail_stop = is_long ? current_price - trail_distance : current_price + trail_distance
    
    // Only update if new stop is better (tighter) than current stop
    // For long: new stop should be higher than current
    // For short: new stop should be lower than current
    float updated_trail_stop = is_long ? 
                               math.max(current_trail_stop, new_trail_stop) : 
                               math.min(current_trail_stop, new_trail_stop)
    
    updated_trail_stop

// Master function to calculate all take profit levels
// Parameters:
// - entry_price: The entry price for the trade
// - stop_loss_price: The stop loss price
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: [TP1 price, TP2 price, TP3 trail distance]
calculate_take_profit_levels(float entry_price, float stop_loss_price, int tier, bool is_long) =>
    // Calculate stop distance in price units
    float stop_distance = math.abs(entry_price - stop_loss_price)
    
    // Calculate TP1 (40% position at 0.6:1 R:R)
    float tp1 = calculate_tp1(entry_price, stop_distance, tier, is_long)
    
    // Calculate TP2 (40% position at 1.2:1 R:R)
    float tp2 = calculate_tp2(entry_price, stop_distance, tier, is_long)
    
    // Calculate TP3 trailing distance (20% position with 0.8x ATR trail)
    // ERROR HANDLING: Use safe ATR value
    float tp3_trail_dist = calculate_tp3_trail_distance(safe_atr)
    
    [tp1, tp2, tp3_trail_dist]

// ----------------------------------------------------------------------------
// 7.4 Implement immediate breakeven management system
// ----------------------------------------------------------------------------

// Function to calculate breakeven price with small offset
// Moves stop to entry + 0.1% (long) or entry - 0.1% (short)
// Parameters:
// - entry_price: The entry price for the trade
// - is_long: True for long positions, false for short positions
// Returns: Breakeven stop loss price
calculate_breakeven_stop(float entry_price, bool is_long) =>
    // Calculate offset as percentage (from inputs, default 0.1%)
    float offset_pct = breakeven_offset_pct / 100
    
    // For long: entry + offset, for short: entry - offset
    float breakeven_price = is_long ? entry_price * (1.0 + offset_pct) : entry_price * (1.0 - offset_pct)
    
    breakeven_price

// Function to check if TP1 has been hit
// Parameters:
// - current_price: Current market price
// - tp1_price: TP1 target price
// - is_long: True for long positions, false for short positions
// Returns: True if TP1 has been reached
check_tp1_hit(float current_price, float tp1_price, bool is_long) =>
    // For long: current price >= TP1
    // For short: current price <= TP1
    bool tp1_reached = is_long ? current_price >= tp1_price : current_price <= tp1_price
    
    tp1_reached

// Function to implement 5-minute rule
// Move to breakeven if trade open 5+ bars without hitting TP1
// Parameters:
// - bars_in_trade: Number of bars since entry
// - tp1_hit: Whether TP1 has been hit
// Returns: True if should move to breakeven
check_5min_rule(int bars_in_trade, bool tp1_hit) =>
    // Only apply if time-based locks are enabled
    bool should_move_to_be = enable_time_locks and 
                             bars_in_trade >= bars_to_breakeven and 
                             not tp1_hit
    
    should_move_to_be

// Function to implement 10-minute rule
// Close 50% at market if trade open 10+ bars without hitting TP1
// Parameters:
// - bars_in_trade: Number of bars since entry
// - tp1_hit: Whether TP1 has been hit
// Returns: True if should close 50% at market
check_10min_rule(int bars_in_trade, bool tp1_hit) =>
    // Only apply if time-based locks are enabled
    bool should_partial_close = enable_time_locks and bars_in_trade >= bars_to_partial_close and not tp1_hit
    
    should_partial_close

// Function to determine if stop should be moved to breakeven
// Combines TP1 hit trigger and 5-minute rule
// Parameters:
// - tp1_hit: Whether TP1 has been hit
// - bars_in_trade: Number of bars since entry
// - breakeven_already_moved: Whether breakeven has already been set
// Returns: True if should move stop to breakeven now
should_move_to_breakeven(bool tp1_hit, int bars_in_trade, bool breakeven_already_moved) =>
    // Don't move if already moved
    if breakeven_already_moved
        false
    else
        // Move to breakeven if:
        // 1. TP1 has been hit (immediate), OR
        // 2. 5-minute rule triggered (time-based protection)
        bool move_now = tp1_hit or check_5min_rule(bars_in_trade, tp1_hit)
        move_now

// Function to update stop loss to breakeven
// Ensures every trade hitting TP1 becomes profitable
// Parameters:
// - current_stop: Current stop loss price
// - entry_price: The entry price for the trade
// - is_long: True for long positions, false for short positions
// Returns: Updated stop loss price (at breakeven + offset)
move_stop_to_breakeven(float current_stop, float entry_price, bool is_long) =>
    // Calculate breakeven stop with offset
    float be_stop = calculate_breakeven_stop(entry_price, is_long)
    
    // Only move stop if new stop is better than current stop
    // For long: new stop should be higher
    // For short: new stop should be lower
    float updated_stop = is_long ? 
                         math.max(current_stop, be_stop) : 
                         math.min(current_stop, be_stop)
    
    updated_stop

// Master function for breakeven management
// Coordinates all breakeven logic and time-based rules
// Parameters:
// - entry_price: The entry price for the trade
// - current_stop: Current stop loss price
// - tp1_price: TP1 target price
// - current_price: Current market price
// - bars_in_trade: Number of bars since entry
// - tp1_already_hit: Whether TP1 has already been hit
// - breakeven_already_moved: Whether breakeven has already been set
// - is_long: True for long positions, false for short positions
// Returns: [new_stop_price, should_close_50pct, breakeven_moved_flag]
manage_breakeven(float entry_price, float current_stop, float tp1_price, float current_price, 
                 int bars_in_trade, bool tp1_already_hit, bool breakeven_already_moved, bool is_long) =>
    
    // Check if TP1 has been hit this bar
    bool tp1_hit_now = check_tp1_hit(current_price, tp1_price, is_long)
    
    // Update TP1 hit status
    bool tp1_hit = tp1_already_hit or tp1_hit_now
    
    // Check if should move to breakeven
    bool move_to_be = should_move_to_breakeven(tp1_hit, bars_in_trade, breakeven_already_moved)
    
    // Calculate new stop loss
    float new_stop = current_stop
    bool be_moved = breakeven_already_moved
    
    if move_to_be
        new_stop := move_stop_to_breakeven(current_stop, entry_price, is_long)
        be_moved := true
    
    // Check 10-minute rule for forced partial close
    bool close_50pct = check_10min_rule(bars_in_trade, tp1_hit)
    
    [new_stop, close_50pct, be_moved, tp1_hit]

// ----------------------------------------------------------------------------
// 7.5 Implement risk validation checks per tier
// ----------------------------------------------------------------------------

// Function to verify stop loss distance is within acceptable range for tier
// Parameters:
// - stop_distance_pct: Stop loss distance as percentage
// - tier: Entry tier (1, 2, or 3)
// Returns: True if stop distance is valid
validate_stop_distance_range(float stop_distance_pct, int tier) =>
    // ERROR HANDLING: Validate stop distance is not NA and is positive
    if na(stop_distance_pct) or stop_distance_pct <= 0
        false  // Invalid stop distance
    else
        // Define tier-specific acceptable ranges
        float min_acceptable = tier == 3 ? 0.002 : (tier == 2 ? 0.003 : min_sl_distance_pct / 100)
        float max_acceptable = tier == 3 ? 0.003 : (tier == 2 ? 0.015 : max_sl_distance_pct / 100)
        
        // ERROR HANDLING: Verify stop loss is not too close to entry
        // ERROR HANDLING: Ensure stop loss is not too far from entry
        // Check if stop distance is within range
        bool is_valid = stop_distance_pct >= min_acceptable and stop_distance_pct <= max_acceptable
        
        is_valid

// Function to ensure minimum R:R ratio is met (varies by tier)
// Parameters:
// - entry_price: The entry price for the trade
// - stop_loss_price: The stop loss price
// - tp1_price: First take profit price
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: True if minimum R:R ratio is met
validate_risk_reward_ratio(float entry_price, float stop_loss_price, float tp1_price, int tier, bool is_long) =>
    // Calculate stop distance
    float stop_distance = math.abs(entry_price - stop_loss_price)
    
    // Calculate reward distance (to TP1)
    float reward_distance = math.abs(tp1_price - entry_price)
    
    // Calculate R:R ratio
    float rr_ratio = stop_distance > 0 ? reward_distance / stop_distance : 0.0
    
    // Define minimum R:R ratio per tier
    // Tier 1: 0.5:1 minimum (aggressive scalping)
    // Tier 2: 0.4:1 minimum (more aggressive)
    // Tier 3: 0.3:1 minimum (very aggressive quick scalps)
    float min_rr = tier == 1 ? 0.5 : (tier == 2 ? 0.4 : 0.3)
    
    // Check if R:R meets minimum
    bool is_valid = rr_ratio >= min_rr
    
    is_valid

// Function to validate position size doesn't exceed limits
// Parameters:
// - position_size_pct: Calculated position size as percentage of equity
// Returns: True if position size is within limits
validate_position_size_limits(float position_size_pct) =>
    // Define absolute limits
    float min_limit = 5.0    // Minimum 5% of equity
    float max_limit = 100.0  // Maximum 100% of equity
    
    // Check if position size is within limits
    bool is_valid = position_size_pct >= min_limit and position_size_pct <= max_limit
    
    is_valid

// Function to validate ATR is not NA or zero
// Returns: True if ATR is valid for calculations
validate_atr() =>
    // ERROR HANDLING: Check safe ATR is valid
    bool is_valid = not na(safe_atr) and safe_atr > 0
    
    is_valid

// Function to validate entry price is valid
// Parameters:
// - entry_price: The entry price to validate
// Returns: True if entry price is valid
validate_entry_price(float entry_price) =>
    bool is_valid = not na(entry_price) and entry_price > 0
    
    is_valid

// Master risk validation function
// Combines all validation checks to determine if trade should proceed
// Parameters:
// - entry_price: The entry price for the trade
// - stop_loss_price: The stop loss price
// - tp1_price: First take profit price
// - position_size_pct: Calculated position size as percentage
// - tier: Entry tier (1, 2, or 3)
// - is_long: True for long positions, false for short positions
// Returns: [is_valid, validation_message]
validate_trade_risk(float entry_price, float stop_loss_price, float tp1_price, float position_size_pct, int tier, bool is_long) =>
    
    // Initialize validation result
    bool is_valid = true
    string message = "Valid"
    
    // 1. Validate ATR is available
    if not validate_atr()
        is_valid := false
        message := "Invalid ATR"
    
    // 2. Validate entry price
    else if not validate_entry_price(entry_price)
        is_valid := false
        message := "Invalid Entry Price"
    
    // 3. Validate stop loss distance
    else
        float stop_distance_pct = math.abs(entry_price - stop_loss_price) / entry_price
        
        if not validate_stop_distance_range(stop_distance_pct, tier)
            is_valid := false
            message := "Stop Distance Out of Range"
        
        // 4. Validate R:R ratio
        else if not validate_risk_reward_ratio(entry_price, stop_loss_price, tp1_price, tier, is_long)
            is_valid := false
            message := "R:R Ratio Too Low"
        
        // 5. Validate position size
        else if not validate_position_size_limits(position_size_pct)
            is_valid := false
            message := "Position Size Out of Limits"
    
    [is_valid, message]

// Function to check if trade should be skipped due to invalid risk parameters
// Parameters:
// - validation_result: Result from validate_trade_risk
// Returns: True if trade should be skipped
should_skip_trade(bool validation_result) =>
    bool skip = not validation_result
    
    skip

// ============================================================================
// IMPLEMENTATION STATUS
// ============================================================================

// COMPLETED MODULES:
// ✓ Task 1: Pine Script v5 strategy foundation and input parameters
// ✓ Task 2: Volatility analysis module (ATR, Kaufman Efficiency, composite filter)
// ✓ Task 3: Market structure detection (swing highs/lows, breakouts, liquidity sweeps)
// ✓ Task 4: Momentum filter module (volume, MA slope, candle body, RSI, scoring)
// ✓ Task 5: Tiered entry signal generator (Tier 1/2/3 for high frequency trading)
// ✓ Task 6: Adaptive frequency control system (cooldown, win streak, hourly limits, profit factor)
// ✓ Task 7: Tiered risk management module with profit guarantees
//   ✓ 7.1: Tiered position sizing calculator (equity-based with tier multipliers)
//   ✓ 7.2: Adaptive stop loss calculation (ATR-based, swing-based, tier-specific)
//   ✓ 7.3: Three-tier dynamic take profit system (TP1/TP2/TP3 with trailing)
//   ✓ 7.4: Immediate breakeven management (TP1 trigger, 5-min rule, 10-min rule)
//   ✓ 7.5: Risk validation checks per tier (stop distance, R:R ratio, position limits)

// PENDING MODULES:
// ⏳ Task 8: Tiered trade execution engine with profit protection
// ⏳ Task 9: Visualization system
// ⏳ Task 10: Configuration and customization options
// ⏳ Task 11: Error handling and validation
// ⏳ Task 12: Performance optimization and code quality
// ⏳ Task 13: Final integration and testing

// ============================================================================
// TIERED TRADE EXECUTION ENGINE WITH PROFIT PROTECTION
// ============================================================================

// ----------------------------------------------------------------------------
// 8.1 Create tiered entry order placement logic
// ----------------------------------------------------------------------------

// Trade state variables to track current position
var float trade_entry_price = na
var float trade_stop_loss = na
var float trade_tp1 = na
var float trade_tp2 = na
var float trade_tp3_trail_distance = na
var float trade_trailing_stop = na
var int trade_entry_tier = 0
var int trade_entry_bar = 0
var bool trade_tp1_hit = false
var bool trade_tp2_hit = false
var bool trade_breakeven_moved = false
var bool trade_is_long = false
var float trade_position_size_pct = 0.0
var float trade_stop_distance_pct = 0.0

// NOTE: In Pine Script, we cannot modify global var variables inside functions.
// Therefore, trade state initialization and reset must be done inline where needed.

// Check if we have an open position
has_position = strategy.position_size != 0
is_long_position = strategy.position_size > 0
is_short_position = strategy.position_size < 0

// Entry logic for LONG positions
if enter_long_controlled and not has_position
    // Calculate stop loss and take profit levels
    [calculated_stop, stop_dist_pct] = calculate_adaptive_stop_loss(close, final_entry_tier, true)
    [calculated_tp1, calculated_tp2, tp3_trail_dist] = calculate_take_profit_levels(close, calculated_stop, final_entry_tier, true)
    
    // Calculate position size based on stop distance and tier
    calculated_position_size = calculate_position_size(stop_dist_pct, final_entry_tier)
    final_position_size = apply_position_limits(calculated_position_size)
    
    // Apply tier-specific position size multiplier
    adjusted_position_size = final_position_size * final_position_size_multiplier
    
    // Validate trade risk parameters
    [risk_valid, validation_msg] = validate_trade_risk(close, calculated_stop, calculated_tp1, adjusted_position_size, final_entry_tier, true)
    
    // Only enter if risk validation passes
    if risk_valid
        // Execute entry order with tier-adjusted position size
        strategy.entry("Long", strategy.long, qty=adjusted_position_size, comment="L-T" + str.tostring(final_entry_tier))
        
        // Initialize trade state variables (inline to avoid function scope issues)
        trade_entry_price := close
        trade_stop_loss := calculated_stop
        trade_tp1 := calculated_tp1
        trade_tp2 := calculated_tp2
        trade_tp3_trail_distance := tp3_trail_dist
        trade_trailing_stop := na  // Will be initialized after TP2 hit
        trade_entry_tier := final_entry_tier
        trade_entry_bar := bar_index
        trade_tp1_hit := false
        trade_tp2_hit := false
        trade_breakeven_moved := false
        trade_is_long := true
        trade_position_size_pct := adjusted_position_size
        trade_stop_distance_pct := stop_dist_pct
        
        // Update frequency control: record trade entry
        last_trade_bar := bar_index
        trades_this_hour := trades_this_hour + 1
        
        // Decrement win streak bonus if active
        if win_streak_bonus_active
            win_streak_bonus_trades := win_streak_bonus_trades - 1

// Entry logic for SHORT positions
if enter_short_controlled and not has_position
    // Calculate stop loss and take profit levels
    [calculated_stop, stop_dist_pct] = calculate_adaptive_stop_loss(close, final_entry_tier, false)
    [calculated_tp1, calculated_tp2, tp3_trail_dist] = calculate_take_profit_levels(close, calculated_stop, final_entry_tier, false)
    
    // Calculate position size based on stop distance and tier
    calculated_position_size = calculate_position_size(stop_dist_pct, final_entry_tier)
    final_position_size = apply_position_limits(calculated_position_size)
    
    // Apply tier-specific position size multiplier
    adjusted_position_size = final_position_size * final_position_size_multiplier
    
    // Validate trade risk parameters
    [risk_valid, validation_msg] = validate_trade_risk(close, calculated_stop, calculated_tp1, adjusted_position_size, final_entry_tier, false)
    
    // Only enter if risk validation passes
    if risk_valid
        // Execute entry order with tier-adjusted position size
        strategy.entry("Short", strategy.short, qty=adjusted_position_size, comment="S-T" + str.tostring(final_entry_tier))
        
        // Initialize trade state variables (inline to avoid function scope issues)
        trade_entry_price := close
        trade_stop_loss := calculated_stop
        trade_tp1 := calculated_tp1
        trade_tp2 := calculated_tp2
        trade_tp3_trail_distance := tp3_trail_dist
        trade_trailing_stop := na  // Will be initialized after TP2 hit
        trade_entry_tier := final_entry_tier
        trade_entry_bar := bar_index
        trade_tp1_hit := false
        trade_tp2_hit := false
        trade_breakeven_moved := false
        trade_is_long := false
        trade_position_size_pct := adjusted_position_size
        trade_stop_distance_pct := stop_dist_pct
        
        // Update frequency control: record trade entry
        last_trade_bar := bar_index
        trades_this_hour := trades_this_hour + 1
        
        // Decrement win streak bonus if active
        if win_streak_bonus_active
            win_streak_bonus_trades := win_streak_bonus_trades - 1

// ----------------------------------------------------------------------------
// 8.2 Implement three-tier partial exit system
// ----------------------------------------------------------------------------

// Manage active positions - partial exits and breakeven management
if has_position and not na(trade_entry_price)
    // Calculate bars in trade
    bars_in_trade = bar_index - trade_entry_bar
    
    // Check if TP1 has been reached
    if not trade_tp1_hit
        bool tp1_reached = trade_is_long ? high >= trade_tp1 : low <= trade_tp1
        
        if tp1_reached
            // Close first partial position (40% at TP1)
            strategy.close("Long", qty_percent=partial_close_tp1_pct, comment="TP1")
            strategy.close("Short", qty_percent=partial_close_tp1_pct, comment="TP1")
            
            // Mark TP1 as hit
            trade_tp1_hit := true
            
            // Move stop loss to breakeven + offset immediately
            trade_stop_loss := calculate_breakeven_stop(trade_entry_price, trade_is_long)
            trade_breakeven_moved := true
    
    // Check if TP2 has been reached (only after TP1)
    if trade_tp1_hit and not trade_tp2_hit
        bool tp2_reached = trade_is_long ? high >= trade_tp2 : low <= trade_tp2
        
        if tp2_reached
            // Close second partial position (40% at TP2)
            strategy.close("Long", qty_percent=partial_close_tp2_pct, comment="TP2")
            strategy.close("Short", qty_percent=partial_close_tp2_pct, comment="TP2")
            
            // Mark TP2 as hit
            trade_tp2_hit := true
            
            // Initialize trailing stop for remaining 20% position
            trade_trailing_stop := initialize_trailing_stop(trade_entry_price, close, trade_tp3_trail_distance, trade_is_long)

// ----------------------------------------------------------------------------
// 8.3 Create tight trailing stop logic for runners
// ----------------------------------------------------------------------------

    // Update trailing stop for remaining 20% position (only after TP2 hit)
    if trade_tp2_hit and not na(trade_trailing_stop)
        // Update trailing stop as price moves favorably
        trade_trailing_stop := update_trailing_stop(trade_trailing_stop, close, 
                                                     trade_tp3_trail_distance, trade_is_long)
        
        // Check if trailing stop has been hit
        bool trailing_stop_hit = trade_is_long ? low <= trade_trailing_stop : high >= trade_trailing_stop
        
        if trailing_stop_hit
            // Close remaining 20% position when trailing stop hit
            strategy.close("Long", qty_percent=100, comment="Trail")
            strategy.close("Short", qty_percent=100, comment="Trail")

// ----------------------------------------------------------------------------
// 8.4 Implement immediate breakeven and time-based profit locks
// ----------------------------------------------------------------------------

    // Implement 5-bar rule: move to breakeven if no TP1 after 5 bars
    if not trade_breakeven_moved and check_5min_rule(bars_in_trade, trade_tp1_hit)
        // Move stop loss to breakeven + offset
        trade_stop_loss := calculate_breakeven_stop(trade_entry_price, trade_is_long)
        trade_breakeven_moved := true
    
    // Implement 10-bar rule: close 50% at market if no TP1 after 10 bars
    if check_10min_rule(bars_in_trade, trade_tp1_hit)
        // Close 50% of position at market
        strategy.close("Long", qty_percent=50, comment="10-Bar")
        strategy.close("Short", qty_percent=50, comment="10-Bar")
        
        // Move to breakeven if not already moved
        if not trade_breakeven_moved
            trade_stop_loss := calculate_breakeven_stop(trade_entry_price, trade_is_long)
            trade_breakeven_moved := true
    
    // Apply stop loss exit (ensure stop loss never moves against position)
    // For long positions: stop should only move up
    // For short positions: stop should only move down
    if trade_is_long
        strategy.exit("Long SL", "Long", stop=trade_stop_loss)
    else
        strategy.exit("Short SL", "Short", stop=trade_stop_loss)

// ----------------------------------------------------------------------------
// 8.5 Create comprehensive trade state management
// ----------------------------------------------------------------------------

// Reset trade state when position is closed
if not has_position and not na(trade_entry_price)
    // Trade has been closed, reset all state variables (inline to avoid function scope issues)
    trade_entry_price := na
    trade_stop_loss := na
    trade_tp1 := na
    trade_tp2 := na
    trade_tp3_trail_distance := na
    trade_trailing_stop := na
    trade_entry_tier := 0
    trade_entry_bar := 0
    trade_tp1_hit := false
    trade_tp2_hit := false
    trade_breakeven_moved := false
    trade_is_long := false
    trade_position_size_pct := 0.0
    trade_stop_distance_pct := 0.0

// ----------------------------------------------------------------------------
// 8.6 Implement post-trade analysis for frequency control
// ----------------------------------------------------------------------------

// Track closed trades for frequency control and performance analysis
if strategy.closedtrades > strategy.closedtrades[1]
    // A trade was just closed
    
    // Get the profit/loss of the last closed trade
    last_trade_profit = strategy.closedtrades.profit(strategy.closedtrades - 1)
    
    // Determine if closed trade was win or loss
    bool was_winning_trade = last_trade_profit > 0
    
    // Update consecutive win/loss counters
    if was_winning_trade
        consecutive_wins := consecutive_wins + 1
        consecutive_losses := 0
        last_trade_was_win := true
        
        // Update win streak bonus
        if enable_win_streak_bonus
            win_streak_bonus_trades := update_win_streak_bonus()
    else
        consecutive_losses := consecutive_losses + 1
        consecutive_wins := 0
        last_trade_was_win := false
        
        // Reset win streak bonus on loss
        win_streak_bonus_trades := 0
    
    // Update gross profit/loss for profit factor calculation
    if was_winning_trade
        total_gross_profit := total_gross_profit + last_trade_profit
    else
        total_gross_loss := total_gross_loss + math.abs(last_trade_profit)
    
    // Calculate session profit factor
    current_profit_factor := total_gross_loss > 0 ? total_gross_profit / total_gross_loss : 0.0
    
    // Check if profit factor is below threshold
    profit_factor_low := current_profit_factor < profit_factor_threshold and strategy.closedtrades >= 5
    
    // Trigger recovery mode if needed (3 consecutive losses)
    if consecutive_losses >= 3
        recovery_mode := true
    
    // Exit recovery mode after 2 consecutive wins
    if consecutive_wins >= 2
        recovery_mode := false

// ============================================================================
// VISUALIZATION SYSTEM
// ============================================================================

// ----------------------------------------------------------------------------
// 9.1 Create entry/exit markers
// ----------------------------------------------------------------------------

// REALISTIC ENTRY SIGNALS - Relaxed conditions for crypto scalping
// These use practical conditions that will generate signals in real market conditions

// Relaxed long signal conditions:
// 1. Bullish candle (close > open)
// 2. Price momentum (close > close[2])  
// 3. Volume above average
// 4. Not in extreme overbought (RSI < 75)
realistic_long_signal = close > open and 
                       close > close[2] and 
                       volume > volume_ma and 
                       rsi < 75 and
                       not market_is_choppy

// Relaxed short signal conditions:
// 1. Bearish candle (close < open)
// 2. Price momentum (close < close[2])
// 3. Volume above average  
// 4. Not in extreme oversold (RSI > 25)
realistic_short_signal = close < open and close < close[2] and volume > volume_ma and rsi > 25 and not market_is_choppy

// Plot realistic entry signals
plotshape(realistic_long_signal, title="BUY Signal", style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.normal)
plotshape(realistic_short_signal, title="SELL Signal", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.normal)

// Add labels for realistic signals
if realistic_long_signal
    label.new(bar_index, low, "BUY", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)

if realistic_short_signal
    label.new(bar_index, high, "SELL", style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.small)

// Keep original complex signals for comparison (will rarely appear)
plotshape(enter_long_controlled, title="Original Long", style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny)
plotshape(enter_short_controlled, title="Original Short", style=shape.circle, location=location.abovebar, color=color.new(color.orange, 0), size=size.tiny)

// ----------------------------------------------------------------------------
// ALERT SYSTEM
// ----------------------------------------------------------------------------

// JSON Alert Messages for Smart Webhook (exact same format as Target_Trend_V1-pasith.pine)
buy_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "buy", "balance_percentage": ' + str.tostring(alert_quantity) + ', "leverage": ' + str.tostring(alert_leverage) + ', "entry": ' + str.tostring(close) + '}'

sell_alert_message = '{"symbol": "' + syminfo.ticker + '", "action": "sell", "balance_percentage": ' + str.tostring(alert_quantity) + ', "leverage": ' + str.tostring(alert_leverage) + ', "entry": ' + str.tostring(close) + '}'

// Fire alerts when signals occur (only when bar is confirmed)
if enable_alerts and realistic_long_signal and barstate.isconfirmed
    alert(buy_alert_message, alert.freq_once_per_bar)
    
if enable_alerts and realistic_short_signal and barstate.isconfirmed
    alert(sell_alert_message, alert.freq_once_per_bar)

// Optional: Also fire alerts for original complex signals (if they ever trigger)
if enable_alerts and enter_long_controlled and barstate.isconfirmed
    alert(buy_alert_message, alert.freq_once_per_bar)
    
if enable_alerts and enter_short_controlled and barstate.isconfirmed
    alert(sell_alert_message, alert.freq_once_per_bar)

// Add exit markers at trade close points
// Detect when position closes (had position last bar, no position this bar)
position_closed = has_position[1] and not has_position

// Determine if last trade was profitable
last_closed_profit = strategy.closedtrades > 0 ? strategy.closedtrades.profit(strategy.closedtrades - 1) : 0
exit_was_profitable = last_closed_profit > 0

// Plot exit markers with color based on profit/loss
plotshape(position_closed,title="Exit",style=shape.circle,location=location.absolute,color=exit_was_profitable ? color.new(color.green, 30) : color.new(color.red, 30),size=size.tiny)

// ----------------------------------------------------------------------------
// 9.2 Draw stop loss and take profit lines
// ----------------------------------------------------------------------------

// Plot red solid line for active stop loss
plot(show_sl_tp_lines and has_position ? trade_stop_loss : na, title="Stop Loss",color=color.new(color.red, 0),linewidth=2,style=plot.style_line)

// Plot green dashed line for TP1 level
plot(show_sl_tp_lines and has_position and not trade_tp1_hit ? trade_tp1 : na,title="Take Profit 1",color=color.new(color.green, 0),linewidth=1,style=plot.style_linebr)

// Plot blue dashed line for TP2 level
plot(show_sl_tp_lines and has_position and trade_tp1_hit and not trade_tp2_hit ? trade_tp2 : na,title="Take Profit 2",color=color.new(color.blue, 0),linewidth=1,style=plot.style_linebr)

// Plot purple crosses for trailing stop (only active after TP2 hit)
plot(show_sl_tp_lines and has_position and trade_tp2_hit and not na(trade_trailing_stop) ? trade_trailing_stop : na,title="Trailing Stop",color=color.new(color.purple, 0),linewidth=2,style=plot.style_cross)

// ----------------------------------------------------------------------------
// 9.3 Add market condition indicators
// ----------------------------------------------------------------------------

// Shade background gray during choppy markets
bgcolor(show_chop_zones and market_is_choppy ? color.new(color.gray, 90) : na,title="Choppy Market Zone")

// Mark swing highs with small triangles
plotshape(show_swing_points and high == recent_swing_high,title="Swing High",style=shape.triangledown,location=location.abovebar,color=color.new(color.orange, 50),size=size.tiny)

// Mark swing lows with small triangles
plotshape(show_swing_points and low == recent_swing_low,title="Swing Low",style=shape.triangleup,location=location.belowbar,color=color.new(color.orange, 50),size=size.tiny)

// Draw horizontal lines at key breakout levels
// Only show when there's an active breakout
var line swing_high_line = na
var line swing_low_line = na

if show_swing_points and (bullish_breakout or bearish_breakout)
    // Draw swing high line
    if not na(prev_swing_high)
        swing_high_line := line.new(bar_index - swing_lookback, prev_swing_high,bar_index, prev_swing_high,color=color.new(color.orange, 70),width=1,style=line.style_dashed)
    
    // Draw swing low line
    if not na(prev_swing_low)
        swing_low_line := line.new( bar_index - swing_lookback, prev_swing_low, bar_index, prev_swing_low, color=color.new(color.orange, 70), width=1,style=line.style_dashed )

// ----------------------------------------------------------------------------
// 9.4 Create enhanced performance statistics table with tier breakdown
// ----------------------------------------------------------------------------

// Track tier-specific trade counts
var int tier1_trades = 0
var int tier2_trades = 0
var int tier3_trades = 0
var int tier1_wins = 0
var int tier2_wins = 0
var int tier3_wins = 0

// Update tier counts when entering a trade
if enter_long_controlled or enter_short_controlled
    if final_entry_tier == 1
        tier1_trades := tier1_trades + 1
    else if final_entry_tier == 2
        tier2_trades := tier2_trades + 1
    else if final_entry_tier == 3
        tier3_trades := tier3_trades + 1

// Update tier win counts when closing a profitable trade
if position_closed and exit_was_profitable
    // Track which tier the closed trade was from (stored in trade state)
    if trade_entry_tier == 1
        tier1_wins := tier1_wins + 1
    else if trade_entry_tier == 2
        tier2_wins := tier2_wins + 1
    else if trade_entry_tier == 3
        tier3_wins := tier3_wins + 1

// Build table in top-right corner with 2-3 columns
if show_stats_table
    var table stats_table = table.new(position.top_right, 3, 18, 
                                       border_width=1, 
                                       border_color=color.new(color.gray, 50),
                                       frame_width=1,
                                       frame_color=color.new(color.gray, 50))
    
    // Calculate statistics
    total_trades = strategy.closedtrades
    win_rate = total_trades > 0 ? (strategy.wintrades / total_trades) * 100 : 0
    net_profit = strategy.netprofit
    profit_factor = strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : 0
    avg_win = strategy.wintrades > 0 ? strategy.grossprofit / strategy.wintrades : 0
    avg_loss = strategy.losstrades > 0 ? math.abs(strategy.grossloss) / strategy.losstrades : 0
    max_dd = strategy.max_drawdown
    
    // Calculate tier-specific win rates
    tier1_wr = tier1_trades > 0 ? (tier1_wins / tier1_trades) * 100 : 0
    tier2_wr = tier2_trades > 0 ? (tier2_wins / tier2_trades) * 100 : 0
    tier3_wr = tier3_trades > 0 ? (tier3_wins / tier3_trades) * 100 : 0
    
    // Determine volatility regime text
    vol_regime = is_high_volatility ? "HIGH" : (is_low_volatility ? "LOW" : "NORMAL")
    
    // Determine position status
    pos_status = has_position ? (trade_is_long ? "LONG" : "SHORT") : "NONE"
    
    // Color coding
    profit_color = net_profit > 0 ? color.new(color.green, 0) : color.new(color.red, 0)
    pf_color = profit_factor > 2.0 ? color.new(color.green, 0) : 
               (profit_factor > 1.5 ? color.new(color.yellow, 0) : color.new(color.red, 0))
    wr_color = win_rate > 60 ? color.new(color.green, 0) : 
               (win_rate > 50 ? color.new(color.yellow, 0) : color.new(color.orange, 0))
    
    // Header
    table.cell(stats_table, 0, 0, "PERFORMANCE STATS", 
               text_color=color.white, bgcolor=color.new(color.blue, 30), 
               text_size=size.normal)
    table.merge_cells(stats_table, 0, 0, 2, 0)
    
    // Row 1: Net Profit
    table.cell(stats_table, 0, 1, "Net Profit:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 1, str.tostring(net_profit, "#,###.##"), 
               text_color=profit_color, text_size=size.small)
    table.cell(stats_table, 2, 1, "USD", 
               text_color=color.gray, text_size=size.small)
    
    // Row 2: Total Trades
    table.cell(stats_table, 0, 2, "Total Trades:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 2, str.tostring(total_trades), 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 2, 2, "", text_size=size.small)
    
    // Row 3: Tier Breakdown Header
    table.cell(stats_table, 0, 3, "TIER BREAKDOWN", 
               text_color=color.yellow, bgcolor=color.new(color.gray, 70), 
               text_size=size.small)
    table.merge_cells(stats_table, 0, 3, 2, 3)
    
    // Row 4: Tier 1
    table.cell(stats_table, 0, 4, "Tier 1:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 4, str.tostring(tier1_trades) + " (" + str.tostring(tier1_wr, "#.#") + "%)", 
               text_color=color.green, text_size=size.small)
    table.cell(stats_table, 2, 4, "trades", 
               text_color=color.gray, text_size=size.small)
    
    // Row 5: Tier 2
    table.cell(stats_table, 0, 5, "Tier 2:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 5, str.tostring(tier2_trades) + " (" + str.tostring(tier2_wr, "#.#") + "%)", 
               text_color=color.yellow, text_size=size.small)
    table.cell(stats_table, 2, 5, "trades", 
               text_color=color.gray, text_size=size.small)
    
    // Row 6: Tier 3
    table.cell(stats_table, 0, 6, "Tier 3:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 6, str.tostring(tier3_trades) + " (" + str.tostring(tier3_wr, "#.#") + "%)", 
               text_color=color.orange, text_size=size.small)
    table.cell(stats_table, 2, 6, "trades", 
               text_color=color.gray, text_size=size.small)
    
    // Row 7: Win Rate
    table.cell(stats_table, 0, 7, "Win Rate:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 7, str.tostring(win_rate, "#.##") + "%", 
               text_color=wr_color, text_size=size.small)
    table.cell(stats_table, 2, 7, "", text_size=size.small)
    
    // Row 8: Profit Factor
    table.cell(stats_table, 0, 8, "Profit Factor:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 8, str.tostring(profit_factor, "#.##"), 
               text_color=pf_color, text_size=size.small)
    table.cell(stats_table, 2, 8, "", text_size=size.small)
    
    // Row 9: Avg Win
    table.cell(stats_table, 0, 9, "Avg Win:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 9, str.tostring(avg_win, "#.##"), 
               text_color=color.green, text_size=size.small)
    table.cell(stats_table, 2, 9, "USD", 
               text_color=color.gray, text_size=size.small)
    
    // Row 10: Avg Loss
    table.cell(stats_table, 0, 10, "Avg Loss:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 10, str.tostring(avg_loss, "#.##"), 
               text_color=color.red, text_size=size.small)
    table.cell(stats_table, 2, 10, "USD", 
               text_color=color.gray, text_size=size.small)
    
    // Row 11: Max Drawdown
    table.cell(stats_table, 0, 11, "Max DD:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 11, str.tostring(max_dd, "#.##") + "%", 
               text_color=color.red, text_size=size.small)
    table.cell(stats_table, 2, 11, "", text_size=size.small)
    
    // Row 12: Current Position Header
    table.cell(stats_table, 0, 12, "CURRENT STATUS", 
               text_color=color.yellow, bgcolor=color.new(color.gray, 70), 
               text_size=size.small)
    table.merge_cells(stats_table, 0, 12, 2, 12)
    
    // Row 13: Position Status
    table.cell(stats_table, 0, 13, "Position:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 13, pos_status, 
               text_color=has_position ? (trade_is_long ? color.green : color.red) : color.gray, 
               text_size=size.small)
    table.cell(stats_table, 2, 13, "", text_size=size.small)
    
    // Row 14: Entry Tier
    table.cell(stats_table, 0, 14, "Entry Tier:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 14, has_position ? str.tostring(trade_entry_tier) : "-", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 2, 14, "", text_size=size.small)
    
    // Row 15: Trades This Hour
    table.cell(stats_table, 0, 15, "Trades/Hour:", 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 1, 15, str.tostring(trades_this_hour) + "/" + str.tostring(hourly_trade_limit), 
               text_color=color.white, text_size=size.small)
    table.cell(stats_table, 2, 15, "", text_size=size.small)
    
    // Row 16: Consecutive Wins/Losses
    table.cell(stats_table, 0, 16, "Streak:", 
               text_color=color.white, text_size=size.small)
    streak_text = consecutive_wins > 0 ? str.tostring(consecutive_wins) + "W" : 
                  (consecutive_losses > 0 ? str.tostring(consecutive_losses) + "L" : "0")
    streak_color = consecutive_wins > 0 ? color.green : 
                   (consecutive_losses > 0 ? color.red : color.gray)
    table.cell(stats_table, 1, 16, streak_text, 
               text_color=streak_color, text_size=size.small)
    table.cell(stats_table, 2, 16, "", text_size=size.small)
    
    // Row 17: Win Streak Bonus Status
    table.cell(stats_table, 0, 17, "Bonus:", 
               text_color=color.white, text_size=size.small)
    bonus_text = win_streak_bonus_active ? "ACTIVE (" + str.tostring(win_streak_bonus_trades) + ")" : "OFF"
    table.cell(stats_table, 1, 17, bonus_text, 
               text_color=win_streak_bonus_active ? color.green : color.gray, 
               text_size=size.small)
    table.cell(stats_table, 2, 17, "", text_size=size.small)

// ----------------------------------------------------------------------------
// 9.5 Implement filtered signal markers
// ----------------------------------------------------------------------------

// Detect signals that were filtered out
// Long signals that met basic criteria but were rejected
filtered_long_signal = (tier1_long_entry or tier2_long_entry or tier3_long_entry) and 
                       not can_trade and 
                       not has_position

// Short signals that met basic criteria but were rejected
filtered_short_signal = (tier1_short_entry or tier2_short_entry or tier3_short_entry) and  not can_trade and  not has_position

// Determine rejection reason (for optional display)
rejection_reason = not cooldown_satisfied ? "Cooldown" : 
                   (not hourly_limit_satisfied ? "Hourly Limit" : 
                   (recovery_mode and selected_entry_tier != 1 ? "Recovery Mode" : 
                   (profit_factor_low ? "Low PF" : "Unknown")))

// Plot small markers for rejected signals (only if enabled)
plotshape(show_filtered_signals and filtered_long_signal,title="Filtered Long",style=shape.xcross,location=location.belowbar,color=color.new(color.green, 70),size=size.tiny)

plotshape(show_filtered_signals and filtered_short_signal,title="Filtered Short",style=shape.xcross,location=location.abovebar,color=color.new(color.red, 70),size=size.tiny)

// Optional: Add labels with rejection reason (commented out to avoid clutter)
// if show_filtered_signals and filtered_long_signal
//     label.new(bar_index, low, rejection_reason, 
//               style=label.style_label_up, 
//               color=color.new(color.gray, 50), 
//               textcolor=color.white, 
//               size=size.tiny)

// if show_filtered_signals and filtered_short_signal
//     label.new(bar_index, high, rejection_reason, 
//               style=label.style_label_down, 
//               color=color.new(color.gray, 50), 
//               textcolor=color.white, 
//               size=size.tiny)

// ============================================================================
// MARKET CONDITION INDICATORS (Optional - can be removed)
// ============================================================================

// Show market conditions with subtle background colors
bgcolor(market_is_choppy ? color.new(color.gray, 95) : na, title="Choppy Market")
bgcolor(realistic_long_signal ? color.new(color.green, 98) : na, title="Long Signal Active")
bgcolor(realistic_short_signal ? color.new(color.red, 98) : na, title="Short Signal Active")

// Key metrics in data window (optional)
plot(rsi, "RSI", color=color.purple, display=display.data_window)
plot(momentum_score_long, "Momentum Long", color=color.blue, display=display.data_window)
plot(momentum_score_short, "Momentum Short", color=color.red, display=display.data_window)

// Debug Table to show current status (similar to Target_Trend)
if show_stats_table and barstate.islast
    var table debug_table = table.new(position.top_left, 2, 8, bgcolor=color.white, border_width=1)
    
    table.cell(debug_table, 0, 0, "Crypto Scalper Status", text_color=color.white, bgcolor=color.new(color.blue, 0))
    table.cell(debug_table, 1, 0, "Value", text_color=color.white, bgcolor=color.new(color.blue, 0))
    
    table.cell(debug_table, 0, 1, "Market Condition", text_color=color.black)
    table.cell(debug_table, 1, 1, market_is_choppy ? "Choppy" : "Tradeable", text_color=market_is_choppy ? color.red : color.green)
    
    table.cell(debug_table, 0, 2, "RSI", text_color=color.black)
    table.cell(debug_table, 1, 2, str.tostring(math.round(rsi, 1)), text_color=rsi > 70 ? color.red : rsi < 30 ? color.green : color.black)
    
    table.cell(debug_table, 0, 3, "Momentum Long", text_color=color.black)
    table.cell(debug_table, 1, 3, str.tostring(momentum_score_long), text_color=momentum_score_long >= 2 ? color.green : color.gray)
    
    table.cell(debug_table, 0, 4, "Momentum Short", text_color=color.black)
    table.cell(debug_table, 1, 4, str.tostring(momentum_score_short), text_color=momentum_score_short >= 2 ? color.red : color.gray)
    
    table.cell(debug_table, 0, 5, "Can Trade", text_color=color.black)
    table.cell(debug_table, 1, 5, can_trade ? "Yes" : "No", text_color=can_trade ? color.green : color.red)
    
    table.cell(debug_table, 0, 6, "Long Signal", text_color=color.black)
    table.cell(debug_table, 1, 6, realistic_long_signal ? "ACTIVE" : "Off", text_color=realistic_long_signal ? color.green : color.gray)
    
    table.cell(debug_table, 0, 7, "Short Signal", text_color=color.black)
    table.cell(debug_table, 1, 7, realistic_short_signal ? "ACTIVE" : "Off", text_color=realistic_short_signal ? color.red : color.gray)
